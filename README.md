# Goè¯­è¨€è‡ªå­¦ç¬”è®°

| æ—¥æœŸ       | å†…å®¹                  |
| ---------- | --------------------- |
| 2025.07.03 | è¯‘è€…åºã€å‰è¨€ã€1.1 1.2 |
| 2025.07.04 | 1.3                   |
| 2025.07.07 | 1.4ã€1.5              |
| 2025.07.09 | 1.6ã€1.7              |

## ä¸€ã€ä¸ºä»€ä¹ˆè¦å­¦

  ä¸­å›½æœ‰å¥å¤è¯ï¼Œä¸‰æ€è€Œåè¡Œã€‚è‹±æ–‡å°±æ˜¯one, two ,three , Go.æ‰€ä»¥ä¸‰æ€åè¦å­¦Goï¼ˆå¼€ä¸ªç©ç¬‘ï¼‰ã€‚

ä»¥ä¸‹å†…å®¹æºè‡ªäº’è”ç½‘ï¼š

  Golang â€”â€” è®©ä½ ç”¨å†™Pythonä»£ç çš„å¼€å‘æ•ˆç‡ç¼–å†™å‡ºC++ä»£ç çš„æ€§èƒ½ã€‚

  Goè¯­è¨€(æˆ–Golang)æ˜¯Golanguageçš„ç®€ç§°ï¼ŒGoæ˜¯Googleçš„Ken Thompsonï¼ŒRob Pikeä»¥åŠRobert Griesemerå¼€å‘çš„ä¸€ç§é™æ€å¼ºç±»å‹ã€ç¼–è¯‘å¹¶å‘å‹è¯­è¨€ã€‚

  å­¦ä¹ Goè¯­è¨€çš„ä¸»è¦åŸå› æ˜¯å…¶åœ¨å¹¶å‘ç¼–ç¨‹ã€ç³»ç»Ÿç¼–ç¨‹å’Œäº‘åŸç”Ÿé¢†åŸŸçš„é«˜æ•ˆæ€§å’Œç®€æ´æ€§ã€‚Goè¯­è¨€ç‰¹åˆ«é€‚åˆæ„å»ºé«˜æ€§èƒ½çš„ç½‘ç»œæœåŠ¡ã€åˆ†å¸ƒå¼ç³»ç»Ÿã€äº‘è®¡ç®—åŸºç¡€è®¾æ–½å’Œå®¹å™¨åŒ–åº”ç”¨ã€‚æ­¤å¤–ï¼ŒGoè¯­è¨€çš„å­¦ä¹ æ›²çº¿ç›¸å¯¹å¹³ç¼“ï¼Œå¯¹äºæœ‰ä¸€å®šç¼–ç¨‹ç»éªŒçš„å¼€å‘è€…æ¥è¯´ï¼Œä¸Šæ‰‹æ¯”è¾ƒå®¹æ˜“ã€‚

   æ­¤å¤–åœ¨å·¥ä½œä¸­æ¥è§¦åˆ°çš„è®¸å¤šä¼˜ç§€çš„äº‘åŸç”Ÿåº”ç”¨å¦‚Dockerï¼ŒKubernetesï¼Œetcdï¼ŒPrometheusç­‰éƒ½ä½¿ç”¨Goè¯­è¨€å¼€å‘ï¼Œæ›´å¼•å‘äº†æˆ‘çš„å…´è¶£ï¼Œæ‰€ä»¥å®šä¸€ä¸ªç›®æ ‡ï¼Œå¸Œæœ›èƒ½å­¦ä¹ æŒæ¡Goè¯­è¨€ï¼Œå¹¶å°è¯•åœ¨è‡ªå·±å–œæ¬¢çš„åŸºäºgoå¼€å‘çš„é¡¹ç›®ä¸­æäº¤è´¡çŒ®ã€‚

## äºŒã€å­¦ä¹ è®°å½•

åç»­å­¦ä¹ åŸºäº[ã€ŠThe Go Programming Languageã€‹ï¼ˆGoè¯­è¨€åœ£ç»ä¸­æ–‡ç‰ˆï¼‰](https://gopl-zh.github.io/index.html)è¿›è¡Œï¼Œè®°å½•ä¸ªäººè§‰å¾—ä¹¦ä¸­å…³é”®å’Œæœ‰æ„æ€çš„å†…å®¹ã€ä»£ç ç»ƒä¹ ç­‰ã€‚

### **å‰è¨€**

åç»­å‚è€ƒå¼•ç”¨ä¼šå°½é‡è¡¨æ˜ï¼Œ*â€œæ–œä½“â€*ä»£è¡¨ç›´æ¥å¼•ç”¨ä¹¦ä¸­å†…å®¹ï¼Œå…¶ä»–å¼•è‡ªäº’è”ç½‘çš„å†…å®¹ä¼šç‰¹åˆ«æ ‡æ³¨ã€‚

---

*â€œGoè¯­è¨€æœ‰æ—¶å€™è¢«æè¿°ä¸ºâ€œç±»Cè¯­è¨€â€ï¼Œæˆ–è€…æ˜¯â€œ21ä¸–çºªçš„Cè¯­è¨€â€ã€‚â€*

*â€œæ­£å¦‚[Rob Pike](http://genius.cat-v.org/rob-pike/)æ‰€è¯´ï¼Œâ€œè½¯ä»¶çš„å¤æ‚æ€§æ˜¯ä¹˜æ³•çº§ç›¸å…³çš„â€ï¼Œé€šè¿‡å¢åŠ ä¸€ä¸ªéƒ¨åˆ†çš„å¤æ‚æ€§æ¥ä¿®å¤é—®é¢˜é€šå¸¸å°†æ…¢æ…¢åœ°å¢åŠ å…¶ä»–éƒ¨åˆ†çš„å¤æ‚æ€§ã€‚é€šè¿‡å¢åŠ åŠŸèƒ½ã€é€‰é¡¹å’Œé…ç½®æ˜¯ä¿®å¤é—®é¢˜çš„æœ€å¿«çš„é€”å¾„ï¼Œä½†æ˜¯è¿™å¾ˆå®¹æ˜“è®©äººå¿˜è®°ç®€æ´çš„å†…æ¶µï¼Œå³ä»é•¿è¿œæ¥çœ‹ï¼Œç®€æ´ä¾ç„¶æ˜¯å¥½è½¯ä»¶çš„å…³é”®å› ç´ ã€‚â€*

---

æœ¬äººå­¦ç”Ÿé˜¶æ®µç–äºå­¦ä¹ ï¼Œæ°´å¹³æœ‰é™ï¼Œå­¦ä¹ è¿‡ç¨‹ä¸­çš„ä¸€äº›å¥‡å¥‡æ€ªæ€ªçš„ç–‘é—®ä¼šè®°å½•æˆQ&Açš„å½¢å¼ï¼ŒAä¸€èˆ¬æ˜¯ä»AIé‚£å¾—åˆ°çš„ç­”æ¡ˆã€‚

---

Qï¼š666

Aï¼šğŸ˜„ ä½ å¤ªå®¢æ°”äº†ï¼

---

**ç¯å¢ƒå®‰è£…**

https://go.dev/doc/install, é€‰æ‹©å¯¹åº”ç‰ˆæœ¬å®‰è£…

```shell
â¯ go version
go version go1.24.4 darwin/arm64
```

åé¢çš„æ ‡é¢˜å¯¹åº”ä¹¦ä¸­æ ‡é¢˜

### 1.<span id="jump1">å…¥é—¨</span>

#### 1.1.Hello, World

â€œ*æˆ‘ä»¬ä»¥ç°å·²æˆä¸ºä¼ ç»Ÿçš„â€œhello worldâ€æ¡ˆä¾‹æ¥å¼€å§‹å§ï¼Œè¿™ä¸ªä¾‹å­é¦–æ¬¡å‡ºç°äº 1978 å¹´å‡ºç‰ˆçš„ C è¯­è¨€åœ£ç» ã€ŠThe C Programming Languageã€‹*â€

```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, world")
}
```

```
â¯ vi helloworld.go
â¯ go run helloworld.go
Hello, world
```

---

Qï¼šgo run helloworld.go è¿è¡Œé€Ÿåº¦æ…¢ï¼ŒåŒæ ·çš„å†™ä¸€ä¸ª.pyè„šæœ¬æ‰§è¡Œé€Ÿåº¦è¦å¿«nå€ï¼Ÿ

Aï¼šå…³é”®åŒºåˆ«ï¼šGo æ˜¯ç¼–è¯‘å‹è¯­è¨€ï¼ŒPython æ˜¯è§£é‡Šå‹è¯­è¨€ã€‚pyç›´æ¥è°ƒç”¨è§£é‡Šå™¨æ‰§è¡Œ `.py` æ–‡ä»¶ï¼Œä¸éœ€è¦ç¼–è¯‘ï¼Œå‡ ä¹æ˜¯**å³ç‚¹å³è¿è¡Œ**ã€‚`go run`å®é™…ä¸Šæ˜¯ä¸¤æ­¥è¿‡ç¨‹ï¼šå…ˆ **ä¸´æ—¶ç¼–è¯‘** æˆäºŒè¿›åˆ¶æ–‡ä»¶ï¼ˆæ”¾åœ¨ä¸´æ—¶ç›®å½•ä¸‹ï¼Œå¦‚ `/tmp`ï¼‰ç„¶åå†æ‰§è¡Œè¿™ä¸ªä¸´æ—¶äºŒè¿›åˆ¶æ–‡ä»¶ã€‚

```
â¯ date;go run helloworld.go;date
2025å¹´ 7æœˆ 3æ—¥ æ˜ŸæœŸå›› 11æ—¶35åˆ†15ç§’ CST
Hello, world
2025å¹´ 7æœˆ 3æ—¥ æ˜ŸæœŸå›› 11æ—¶35åˆ†16ç§’ CST
â¯ go build helloworld.go
â¯ ls
helloworld    helloworld.go
â¯ date;./helloworld;date
2025å¹´ 7æœˆ 3æ—¥ æ˜ŸæœŸå›› 11æ—¶35åˆ†39ç§’ CST
Hello, world
2025å¹´ 7æœˆ 3æ—¥ æ˜ŸæœŸå›› 11æ—¶35åˆ†39ç§’ CST
```

å¯ä»¥çœ‹åˆ°è¿è¡Œç¼–è¯‘åçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¼šå¿«å¾ˆå¤š

---



*Go è¯­è¨€çš„ä»£ç é€šè¿‡**åŒ…**ï¼ˆpackageï¼‰ç»„ç»‡ï¼ŒåŒ…ç±»ä¼¼äºå…¶å®ƒè¯­è¨€é‡Œçš„åº“ï¼ˆlibrariesï¼‰æˆ–è€…æ¨¡å—ï¼ˆmodulesï¼‰ã€‚ä¸€ä¸ªåŒ…ç”±ä½äºå•ä¸ªç›®å½•ä¸‹çš„ä¸€ä¸ªæˆ–å¤šä¸ª `.go` æºä»£ç æ–‡ä»¶ç»„æˆï¼Œç›®å½•å®šä¹‰åŒ…çš„ä½œç”¨ã€‚æ¯ä¸ªæºæ–‡ä»¶éƒ½ä»¥ä¸€æ¡ `package` å£°æ˜è¯­å¥å¼€å§‹ï¼Œè¿™ä¸ªä¾‹å­é‡Œå°±æ˜¯ `package main`ï¼Œè¡¨ç¤ºè¯¥æ–‡ä»¶å±äºå“ªä¸ªåŒ…ï¼Œç´§è·Ÿç€ä¸€ç³»åˆ—å¯¼å…¥ï¼ˆimportï¼‰çš„åŒ…ï¼Œä¹‹åæ˜¯å­˜å‚¨åœ¨è¿™ä¸ªæ–‡ä»¶é‡Œçš„ç¨‹åºè¯­å¥ã€‚*

*Go è¯­è¨€ä¸éœ€è¦åœ¨è¯­å¥æˆ–è€…å£°æ˜çš„æœ«å°¾æ·»åŠ åˆ†å·ï¼Œé™¤éä¸€è¡Œä¸Šæœ‰å¤šæ¡è¯­å¥ã€‚*

*Go è¯­è¨€åœ¨ä»£ç æ ¼å¼ä¸Šé‡‡å–äº†å¾ˆå¼ºç¡¬çš„æ€åº¦ã€‚`gofmt`å·¥å…·æŠŠä»£ç æ ¼å¼åŒ–ä¸ºæ ‡å‡†æ ¼å¼*

---

Qï¼šgo get/install è®¿é—®proxy.golang.orgè¶…æ—¶çš„è§£å†³æ–¹å¼ï¼š

```
go env -w GOPROXY=https://goproxy.cn
```

```
â¯ go install  golang.org/x/tools/cmd/goimports@latest
go: downloading golang.org/x/tools v0.34.0
go: downloading golang.org/x/mod v0.25.0
go: downloading golang.org/x/sync v0.15.0
```

---



#### 1.2.å‘½ä»¤è¡Œå‚æ•°

```go
// Echo2 prints its command-line arguments.
package main

import (
    "fmt"
    "os"
)

func main() {
    s, sep := "", ""
    for _, arg := range os.Args[1:] {
        s += sep + arg
        sep = " "
    }
    fmt.Println(s)
}

```

*ç¬¦å· `:=` æ˜¯ çŸ­å˜é‡å£°æ˜ï¼ˆshort variable declarationï¼‰çš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ˜¯å®šä¹‰ä¸€ä¸ªæˆ–å¤šä¸ªå˜é‡å¹¶æ ¹æ®å®ƒä»¬çš„åˆå§‹å€¼ä¸ºè¿™äº›å˜é‡èµ‹äºˆé€‚å½“ç±»å‹çš„è¯­å¥ã€‚*

*Go è¯­è¨€åªæœ‰ `for` å¾ªç¯è¿™ä¸€ç§å¾ªç¯è¯­å¥ã€‚`for` å¾ªç¯æœ‰å¤šç§å½¢å¼ï¼Œå…¶ä¸­ä¸€ç§å¦‚ä¸‹æ‰€ç¤ºï¼š*

```go
for initialization; condition; post {
    // zero or more statements
}
```



**ç»ƒä¹  1.1ï¼š** ä¿®æ”¹ `echo` ç¨‹åºï¼Œä½¿å…¶èƒ½å¤Ÿæ‰“å° `os.Args[0]`ï¼Œå³è¢«æ‰§è¡Œå‘½ä»¤æœ¬èº«çš„åå­—ã€‚

**ç»ƒä¹  1.2ï¼š** ä¿®æ”¹ `echo` ç¨‹åºï¼Œä½¿å…¶æ‰“å°æ¯ä¸ªå‚æ•°çš„ç´¢å¼•å’Œå€¼ï¼Œæ¯ä¸ªä¸€è¡Œã€‚

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	for i, arg := range os.Args {
		if i == 0 {
			fmt.Println("os.Args[0]= ", arg)
		}
		fmt.Println(i, arg)
	}
}
```

**ç»ƒä¹  1.3ï¼š** åšå®éªŒæµ‹é‡æ½œåœ¨ä½æ•ˆçš„ç‰ˆæœ¬å’Œä½¿ç”¨äº† `strings.Join` çš„ç‰ˆæœ¬çš„è¿è¡Œæ—¶é—´å·®å¼‚ã€‚

```go
// compare.
package main

import (
	"fmt"
	"os"
	"strings"
	"time"
)

func main() {
	now := time.Now()
	var s, sep string
	for i := 1; i < len(os.Args); i++ {
		s += sep + os.Args[i]
		sep = " "
	}
	fmt.Println(s)
	end := time.Now()
	fmt.Println("cost time:", end.Sub(now))

	n_now := time.Now()
	fmt.Println(strings.Join(os.Args[1:], " "))
	n_end := time.Now()
	fmt.Println("Join funcation cost time:", n_end.Sub(n_now))
}
```

#### 1.3.æŸ¥æ‰¾é‡å¤çš„è¡Œ

æœ¬å°ç»“ä»¥æŸ¥æ‰¾é‡å¤è¡Œä¸ºæ¡ˆä¾‹ï¼ŒæåŠäº†å¤šç§è¯»å–æ–¹å¼ï¼ˆæ ‡å‡†è¾“å…¥ã€æ–‡ä»¶é€è¡Œè¯»å–ã€ä¸€æ¬¡æ€§è¯»å–ï¼‰ã€`map`ã€`Printf`ã€å‚æ•°ä¼ é€’ã€é”™è¯¯å¤„ç†ç­‰å†…å®¹ï¼Œæœ‰ä¸€ä¸ªç»ƒä¹ é¢˜ã€‚

ä»æ ‡å‡†è¾“å…¥è¯»å–å†…å®¹

```go
// Dup1 prints the text of each line that appears more than
// once in the standard input, preceded by its count.
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
  //åˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²åˆ°æ•´æ•°çš„ mapï¼Œè®°å½•æ¯è¡Œæ–‡æœ¬å‡ºç°çš„æ¬¡æ•°ã€‚
    counts := make(map[string]int)
  //åˆ›å»ºä¸€ä¸ª Scanner å¯¹è±¡ï¼Œä»æ ‡å‡†è¾“å…¥è¯»å–æ–‡æœ¬ï¼ˆé€è¡Œè¯»å–ï¼‰ã€‚
    input := bufio.NewScanner(os.Stdin)
  /*input.Scan() ä¼šè¯»å–ä¸‹ä¸€è¡Œå†…å®¹ï¼Œç›´åˆ°é‡åˆ° EOFï¼ˆç»“æŸè¾“å…¥ï¼‰ã€‚
		input.Text() è¿”å›å½“å‰è¡Œçš„å­—ç¬¦ä¸²ã€‚
		æ¯è¯»å–ä¸€è¡Œï¼Œå°±å°†è¯¥è¡Œä½œä¸ºé”®åŠ å…¥ map å¹¶é€’å¢æ¬¡æ•°ã€‚
	*/
    for input.Scan() {
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
  
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}

```

ä»æ ‡å‡†è¾“å…¥è¯»å–`bufio.NewScanner(os.Stdin)`

*å†…ç½®å‡½æ•° `make` åˆ›å»ºç©º `map`*

*åŸºäº `range` çš„å¾ªç¯ï¼Œå¹¶åœ¨ `counts` è¿™ä¸ª `map` ä¸Šè¿­ä»£ã€‚è·Ÿä¹‹å‰ç±»ä¼¼ï¼Œæ¯æ¬¡è¿­ä»£å¾—åˆ°ä¸¤ä¸ªç»“æœï¼Œé”®å’Œå…¶åœ¨ `map` ä¸­å¯¹åº”çš„å€¼ã€‚**`map` çš„è¿­ä»£é¡ºåºå¹¶ä¸ç¡®å®š**ï¼Œä»å®è·µæ¥çœ‹ï¼Œè¯¥é¡ºåºéšæœºï¼Œæ¯æ¬¡è¿è¡Œéƒ½ä¼šå˜åŒ–ã€‚è¿™ç§è®¾è®¡æ˜¯æœ‰æ„ä¸ºä¹‹çš„ï¼Œ*

*ç±»ä¼¼äº C æˆ–å…¶å®ƒè¯­è¨€é‡Œçš„ `printf` å‡½æ•°ï¼Œ`fmt.Printf` å‡½æ•°å¯¹ä¸€äº›è¡¨è¾¾å¼äº§ç”Ÿæ ¼å¼åŒ–è¾“å‡ºã€‚*

*`Printf` æœ‰ä¸€å¤§å †è¿™ç§è½¬æ¢ï¼ŒGoç¨‹åºå‘˜ç§°ä¹‹ä¸ºåŠ¨è¯ï¼ˆverbï¼‰ã€‚ä¸‹é¢çš„è¡¨æ ¼è™½ç„¶è¿œä¸æ˜¯å®Œæ•´çš„è§„èŒƒï¼Œä½†å±•ç¤ºäº†å¯ç”¨çš„å¾ˆå¤šç‰¹æ€§ï¼š*

```text
%d          åè¿›åˆ¶æ•´æ•°
%x, %o, %b  åå…­è¿›åˆ¶ï¼Œå…«è¿›åˆ¶ï¼ŒäºŒè¿›åˆ¶æ•´æ•°ã€‚
%f, %g, %e  æµ®ç‚¹æ•°ï¼š 3.141593 3.141592653589793 3.141593e+00
%t          å¸ƒå°”ï¼štrueæˆ–false
%c          å­—ç¬¦ï¼ˆruneï¼‰ (Unicodeç ç‚¹)
%s          å­—ç¬¦ä¸²
%q          å¸¦åŒå¼•å·çš„å­—ç¬¦ä¸²"abc"æˆ–å¸¦å•å¼•å·çš„å­—ç¬¦'c'
%v          å˜é‡çš„è‡ªç„¶å½¢å¼ï¼ˆnatural formatï¼‰
%T          å˜é‡çš„ç±»å‹
%%          å­—é¢ä¸Šçš„ç™¾åˆ†å·æ ‡å¿—ï¼ˆæ— æ“ä½œæ•°ï¼‰
åˆ¶è¡¨ç¬¦\tå’Œæ¢è¡Œç¬¦\n
```

ä»æ–‡ä»¶ä¸­è¯»å–

```go
// Dup2 prints the count and text of lines that appear more than once
// in the input.  It reads from stdin or from a list of named files.
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    counts := make(map[string]int)
    files := os.Args[1:]
    if len(files) == 0 {
        countLines(os.Stdin, counts)
    } else {
        for _, arg := range files {
            f, err := os.Open(arg)
            if err != nil {
                fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
                continue
            }
            countLines(f, counts)
            f.Close()
        }
    }
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}
	
func countLines(f *os.File, counts map[string]int) {
    input := bufio.NewScanner(f)
    for input.Scan() {
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
}

```

*`os.Open` å‡½æ•°è¿”å›ä¸¤ä¸ªå€¼ã€‚ç¬¬ä¸€ä¸ªå€¼æ˜¯è¢«æ‰“å¼€çš„æ–‡ä»¶ï¼ˆ`*os.File`ï¼‰ï¼Œå…¶åè¢« `Scanner` è¯»å–*ã€‚PS:ä½¿ç”¨é€è¡Œè¯»å–ï¼Œ**å†…å­˜å ç”¨æ›´ä½**ï¼ˆæ¯” `ReadFile` æ›´å®‰å…¨ï¼‰

*`os.Open` è¿”å›çš„ç¬¬äºŒä¸ªå€¼æ˜¯å†…ç½® `error` ç±»å‹çš„å€¼ã€‚å¦‚æœ `err` ç­‰äºå†…ç½®å€¼`nil`ï¼ˆè¯‘æ³¨ï¼šç›¸å½“äºå…¶å®ƒè¯­è¨€é‡Œçš„ `NULL`ï¼‰ï¼Œé‚£ä¹ˆæ–‡ä»¶è¢«æˆåŠŸæ‰“å¼€ã€‚*

*è¿›å…¥é”™è¯¯å¤„ç†æµç¨‹åï¼Œ`continue` è¯­å¥ç›´æ¥è·³åˆ° `for` å¾ªç¯çš„ä¸‹ä¸ªè¿­ä»£å¼€å§‹æ‰§è¡Œã€‚*

*å‡½æ•°å’ŒåŒ…çº§åˆ«çš„å˜é‡ï¼ˆpackage-level entitiesï¼‰å¯ä»¥ä»»æ„é¡ºåºå£°æ˜ï¼Œå¹¶ä¸å½±å“å…¶è¢«è°ƒç”¨ã€‚*

*`map` æ˜¯ä¸€ä¸ªç”± `make` å‡½æ•°åˆ›å»ºçš„æ•°æ®ç»“æ„çš„å¼•ç”¨ã€‚`map` ä½œä¸ºå‚æ•°ä¼ é€’ç»™æŸå‡½æ•°æ—¶ï¼Œè¯¥å‡½æ•°æ¥æ”¶è¿™ä¸ªå¼•ç”¨çš„ä¸€ä»½æ‹·è´ï¼ˆcopyï¼Œæˆ–è¯‘ä¸ºå‰¯æœ¬ï¼‰ï¼Œè¢«è°ƒç”¨å‡½æ•°å¯¹ `map` åº•å±‚æ•°æ®ç»“æ„çš„ä»»ä½•ä¿®æ”¹ï¼Œè°ƒç”¨è€…å‡½æ•°éƒ½å¯ä»¥é€šè¿‡æŒæœ‰çš„ `map` å¼•ç”¨çœ‹åˆ°ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œ`countLines` å‡½æ•°å‘ `counts` æ’å…¥çš„å€¼ï¼Œä¹Ÿä¼šè¢« `main` å‡½æ•°çœ‹åˆ°ã€‚ï¼ˆè¯‘æ³¨ï¼šç±»ä¼¼äº C++ é‡Œçš„å¼•ç”¨ä¼ é€’ï¼Œå®é™…ä¸ŠæŒ‡é’ˆæ˜¯å¦ä¸€ä¸ªæŒ‡é’ˆäº†ï¼Œä½†å†…éƒ¨å­˜çš„å€¼æŒ‡å‘åŒä¸€å—å†…å­˜ï¼‰*



å‰ä¸¤ä¸ªä¾‹å­åŸºäºâ€œæµâ€çš„æ¨¡å¼è¯»å–æ•°æ®ï¼Œä¸‹é¢å°†å…¨éƒ¨æ•°æ®ä¸€æ¬¡æ€§è¯»å…¥å†…å­˜

```go
package main

import (
    "fmt"
    "io/ioutil"
    "os"
    "strings"
)

func main() {
    counts := make(map[string]int)
    for _, filename := range os.Args[1:] {
        data, err := ioutil.ReadFile(filename)
        if err != nil {
            fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
            continue
        }
      //è½¬æ¢ä¸ºstringåæŒ‰æ¢è¡Œç¬¦åˆ†å‰²
        for _, line := range strings.Split(string(data), "\n") {
            counts[line]++
        }
    }
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}

```



*ç®€åŒ–ï¼Œåªè¯»æŒ‡å®šæ–‡ä»¶ï¼Œä¸è¯»æ ‡å‡†è¾“å…¥ã€‚å…¶æ¬¡ï¼Œç”±äºè¡Œè®¡æ•°ä»£ç åªåœ¨ä¸€å¤„ç”¨åˆ°ï¼Œæ•…å°†å…¶ç§»å› `main` å‡½æ•°ã€‚*

*`ReadFile` å‡½æ•°è¿”å›ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼ˆbyte sliceï¼‰ï¼Œå¿…é¡»æŠŠå®ƒè½¬æ¢ä¸º `string`ï¼Œæ‰èƒ½ç”¨ `strings.Split` åˆ†å‰²ã€‚*

*å®ç°ä¸Šï¼Œ`bufio.Scanner`ã€`ioutil.ReadFile` å’Œ `ioutil.WriteFile` éƒ½ä½¿ç”¨ `*os.File` çš„ `Read` å’Œ `Write` æ–¹æ³•ï¼Œä½†æ˜¯ï¼Œå¤§å¤šæ•°ç¨‹åºå‘˜å¾ˆå°‘éœ€è¦ç›´æ¥è°ƒç”¨é‚£äº›ä½çº§ï¼ˆlower-levelï¼‰å‡½æ•°ã€‚é«˜çº§ï¼ˆhigher-levelï¼‰å‡½æ•°ï¼Œåƒ `bufio` å’Œ `io/ioutil` åŒ…ä¸­æ‰€æä¾›çš„é‚£äº›ï¼Œç”¨èµ·æ¥è¦å®¹æ˜“ç‚¹ã€‚*

**ç»ƒä¹  1.4ï¼š** ä¿®æ”¹ `dup2`ï¼Œå‡ºç°é‡å¤çš„è¡Œæ—¶æ‰“å°æ–‡ä»¶åç§°ã€‚

```go
// Dup2 prints the count and text of lines that appear more than once
// in the input.  It reads from stdin or from a list of named files.
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	// map[filename][line]count
	counts := make(map[string]map[string]int)
	files := os.Args[1:]
	if len(files) == 0 {
		countLines("<stdin>", os.Stdin, counts)
	} else {
		for _, filename := range files {
			f, err := os.Open(filename)
			if err != nil {
				fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
				continue
			}
			countLines(filename, f, counts)
			f.Close()
		}
	}
	for filename, lineMap := range counts {
		for line, n := range lineMap {
			if n > 1 {
				fmt.Printf("%s\t%d\t%s\n", filename, n, line)
			}
		}
	}
}

func countLines(filename string, f *os.File, counts map[string]map[string]int) {
	// å®‰å…¨åˆå§‹åŒ– map çš„æ ‡å‡†å†™æ³•ï¼Œç”¨äºå¤„ç†åµŒå¥— map çš„æƒ…å†µ
	if counts[filename] == nil {
		counts[filename] = make(map[string]int)
	}

	input := bufio.NewScanner(f)
	for input.Scan() {
		line := input.Text()
		counts[filename][line]++
	}
	// NOTE: ignoring potential errors from input.Err()
}
```

æ€è·¯ï¼š

é¦–å…ˆè¦ä¿®æ”¹countsçš„ç±»å‹ä¸ºmap[string]map[string]intï¼Œ

å…¶æ¬¡ä¿®æ”¹countLineså‡½æ•°ï¼Œä½¿å…¶æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼Œå¹¶åœ¨å‡½æ•°ä¸­å¢åŠ å®‰å…¨åˆå§‹åŒ–åµŒå¥—mapçš„æƒ…å†µï¼ˆ`counts` æ˜¯ä¸€ä¸ª mapï¼Œå®ƒçš„å€¼æœ¬èº«åˆæ˜¯ä¸€ä¸ª mapã€‚åœ¨ç¬¬ä¸€æ¬¡è®¿é—® `counts[filename]` æ—¶ï¼Œï¼ˆç¬¬äºŒå±‚ï¼‰é»˜è®¤æ˜¯ `nil`ï¼Œ**ä¸èƒ½ç›´æ¥èµ‹å€¼**ï¼ŒGo ä¼šæŠ¥è¿è¡Œæ—¶é”™è¯¯ï¼‰

ä¿®æ”¹forå¾ªç¯ï¼Œå¤„ç†åµŒå¥—mapçš„æƒ…å†µ

#### 1.4. GIFåŠ¨ç”»

```go
// Lissajous generates GIF animations of random Lissajous figures.
package main

import (
    "image"
    "image/color"
    "image/gif"
    "io"
    "math"
    "math/rand"
    "os"
    "time"
)
/*
color.Color æ˜¯ Go æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªæ¥å£ï¼Œç”¨äºè¡¨ç¤ºâ€œä¸€ä¸ªé¢œè‰²â€ã€‚
éƒ¨åˆ†	å«ä¹‰
var palette	å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œåå­—å« palette
[]color.Color	ç±»å‹æ˜¯ï¼šcolor.Color æ¥å£çš„åˆ‡ç‰‡ï¼ˆå³å¯ä»¥å­˜å¤šä¸ªé¢œè‰²ï¼‰
{color.White, color.Black}	åˆ‡ç‰‡çš„åˆå§‹å€¼æ˜¯ç™½è‰²å’Œé»‘è‰²ä¸¤ä¸ªé¢œè‰²
*/
var palette = []color.Color{color.White, color.Black}

const (
    whiteIndex = 0 // first color in palette
    blackIndex = 1 // next color in palette
)

func main() {
    // The sequence of images is deterministic unless we seed
    // the pseudo-random number generator using the current time.
    // Thanks to Randall McPherson for pointing out the omission.
    rand.Seed(time.Now().UTC().UnixNano())
    lissajous(os.Stdout)
}

func lissajous(out io.Writer) {
    const (
        cycles  = 5     // number of complete x oscillator revolutions
        res     = 0.001 // angular resolution
        size    = 100   // image canvas covers [-size..+size]
        nframes = 64    // number of animation frames
        delay   = 8     // delay between frames in 10ms units
    )

    freq := rand.Float64() * 3.0 // relative frequency of y oscillator
    anim := gif.GIF{LoopCount: nframes}
    phase := 0.0 // phase difference
    for i := 0; i < nframes; i++ {
        rect := image.Rect(0, 0, 2*size+1, 2*size+1)
        img := image.NewPaletted(rect, palette)
        for t := 0.0; t < cycles*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
                blackIndex)
        }
        phase += 0.1
        anim.Delay = append(anim.Delay, delay)
        anim.Image = append(anim.Image, img)
    }
    gif.EncodeAll(out, &anim) // NOTE: ignoring encoding errors
}


```

åœ¨åŒ…çš„å¯¼å…¥è·¯å¾„åŒ…å«å¤šä¸ªå•è¯æ—¶ï¼Œå¦‚â€œimage/colorâ€ï¼Œå¯ä»¥åªç”¨æœ€åä¸€ä¸ªå•è¯è¡¨ç¤º->color.White

åœ¨ Go è¯­è¨€ä¸­ï¼Œ`const` ç”¨äºå£°æ˜**å¸¸é‡**ï¼ˆconstantï¼‰ï¼Œå³åœ¨ç¼–è¯‘æ—¶å°±ç¡®å®šäº†å€¼ï¼Œä¸”è¿è¡Œæ—¶ä¸å¯æ›´æ”¹ã€‚





**ç»ƒä¹  1.5ï¼š** ä¿®æ”¹å‰é¢çš„Lissajousç¨‹åºé‡Œçš„è°ƒè‰²æ¿ï¼Œç”±é»‘è‰²æ”¹ä¸ºç»¿è‰²ã€‚æˆ‘ä»¬å¯ä»¥ç”¨`color.RGBA{0xRR, 0xGG, 0xBB, 0xff}`æ¥å¾—åˆ°`#RRGGBB`è¿™ä¸ªè‰²å€¼ï¼Œä¸‰ä¸ªåå…­è¿›åˆ¶çš„å­—ç¬¦ä¸²åˆ†åˆ«ä»£è¡¨çº¢ã€ç»¿ã€è“åƒç´ ã€‚

```
var palette = []color.Color{color.White, color.RGBA{0x00, 0xff, 0x00, 0xff}} // ç»¿è‰²
```

**ç»ƒä¹  1.6ï¼š** ä¿®æ”¹Lissajousç¨‹åºï¼Œä¿®æ”¹å…¶è°ƒè‰²æ¿æ¥ç”Ÿæˆæ›´ä¸°å¯Œçš„é¢œè‰²ï¼Œç„¶åä¿®æ”¹SetColorIndexçš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œçœ‹çœ‹æ˜¾ç¤ºç»“æœå§ã€‚

```go
var palette = []color.Color{
    color.White,                   // index 0ï¼šèƒŒæ™¯è‰²
    color.RGBA{255, 0, 0, 255},    // index 1ï¼šçº¢
    color.RGBA{255, 165, 0, 255},  // index 2ï¼šæ©™
    color.RGBA{255, 255, 0, 255},  // index 3ï¼šé»„
    color.RGBA{0, 255, 0, 255},    // index 4ï¼šç»¿
    color.RGBA{0, 0, 255, 255},    // index 5ï¼šè“
}
.........
.........
const (
	whiteIndex = 0 // first color in palette
)
........
........
colorIndex := uint8(i%(len(palette)-1) + 1)

		for t := 0.0; t < cycles*2*math.Pi; t += res {
			x := math.Sin(t)
			y := math.Sin(t*freq + phase)
			img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), colorIndex)
		}


```

é¦–å…ˆå®šä¹‰äº†è°ƒè‰²æ¿åŒ…å«ä¸€ä¸ªèƒŒæ™¯è‰²å’Œäº”ä¸ªé¢œè‰²ï¼Œè¿™æ—¶ `len(palette) = 6`ï¼Œå…¶ä¸­ï¼š

- `palette[0]` æ˜¯èƒŒæ™¯ç™½è‰²
- `palette[1]`~`palette[5]` æ˜¯å½©è‰²çº¿æ¡é¢œè‰²



colorIndex := uint8(i%(len(palette)-1) + 1)ç”¨äºéšæœºï¼š

`len(palette) - 1 = 5`ï¼šå»æ‰èƒŒæ™¯è‰²ï¼Œåªç”¨å½©è‰²éƒ¨åˆ†

`i % 5`ï¼šç¡®ä¿å¸§ç¼–å·åœ¨ 0~4 ä¹‹é—´å¾ªç¯ï¼ˆé¿å…è¶…å‡ºç´¢å¼•ï¼‰

`+1`ï¼šè·³è¿‡èƒŒæ™¯è‰² `palette[0]`ï¼Œç¡®ä¿é¢œè‰²ç´¢å¼•ä» 1 å¼€å§‹

uint8ï¼šSetColorIndexéœ€è¦çš„ç±»å‹

#### 1.5.è·å–url

*ä¸ºäº†æœ€ç®€å•åœ°å±•ç¤ºåŸºäºHTTPè·å–ä¿¡æ¯çš„æ–¹å¼ï¼Œä¸‹é¢ç»™å‡ºä¸€ä¸ªç¤ºä¾‹ç¨‹åºfetchï¼Œè¿™ä¸ªç¨‹åºå°†è·å–å¯¹åº”çš„urlï¼Œå¹¶å°†å…¶æºæ–‡æœ¬æ‰“å°å‡ºæ¥ï¼›è¿™ä¸ªä¾‹å­çš„çµæ„Ÿæ¥æºäºcurlå·¥å…·ã€‚å½“ç„¶ï¼Œcurlæä¾›çš„åŠŸèƒ½æ›´ä¸ºå¤æ‚ä¸°å¯Œï¼Œè¿™é‡Œåªç¼–å†™æœ€ç®€å•çš„æ ·ä¾‹ã€‚è¿™ä¸ªæ ·ä¾‹ä¹‹åè¿˜ä¼šå¤šæ¬¡è¢«ç”¨åˆ°ã€‚*

```go
// Fetch prints the content found at a URL.
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
    "os"
)

func main() {
    for _, url := range os.Args[1:] {
        resp, err := http.Get(url)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
            os.Exit(1)
        }
        b, err := io.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
            os.Exit(1)
        }
        fmt.Printf("%s", b)
    }
}

```



**ç»ƒä¹  1.7ï¼š** å‡½æ•°è°ƒç”¨io.Copy(dst, src)ä¼šä»srcä¸­è¯»å–å†…å®¹ï¼Œå¹¶å°†è¯»åˆ°çš„ç»“æœå†™å…¥åˆ°dstä¸­ï¼Œä½¿ç”¨è¿™ä¸ªå‡½æ•°æ›¿ä»£æ‰ä¾‹å­ä¸­çš„ioutil.ReadAllæ¥æ‹·è´å“åº”ç»“æ„ä½“åˆ°os.Stdoutï¼Œé¿å…ç”³è¯·ä¸€ä¸ªç¼“å†²åŒºï¼ˆä¾‹å­ä¸­çš„bï¼‰æ¥å­˜å‚¨ã€‚è®°å¾—å¤„ç†io.Copyè¿”å›ç»“æœä¸­çš„é”™è¯¯ã€‚

```go
// Fetch prints the content found at a URL.
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
)

func main() {
    for _, url := range os.Args[1:] {
        resp, err := http.Get(url)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
            os.Exit(1)
        }
      
       defer resp.Body.Close()
      
        _, err = io.Copy(os.Stdout, resp.Body)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: Copy faild %s: %v\n", url, err)
            os.Exit(1)
        }
    }
}

```

`defer resp.Body.Close()`ï¼š`defer` æ˜¯ Go çš„å»¶è¿Ÿæ‰§è¡Œæœºåˆ¶ï¼Œåœ¨å‡½æ•°ç»“æŸæ—¶è‡ªåŠ¨æ‰§è¡Œã€‚

`resp.Body` æ˜¯ä¸€ä¸ª `io.ReadCloser`ï¼Œå®ƒæ˜¯è¿æ¥æœåŠ¡å™¨çš„æ•°æ®æµé€šé“ã€‚ä½ **å¿…é¡»æ‰‹åŠ¨å…³é—­å®ƒ**ï¼Œå¦åˆ™è¿æ¥ä¼šä¸€ç›´å ç”¨å†…å­˜å’Œèµ„æºã€‚

`io.Copy`æœ‰ä¸¤ä¸ªè¿”å›å€¼ï¼šè¿”å›çš„å­—èŠ‚æ•°ã€errï¼Œæˆ‘ä»¬åªå…³æ³¨è¿”å›çš„é”™è¯¯ï¼Œä½¿ç”¨_å¿½ç•¥ç¬¬ä¸€ä¸ªè¿”å›å€¼ã€‚

**ç»ƒä¹  1.8ï¼š** ä¿®æ”¹fetchè¿™ä¸ªèŒƒä¾‹ï¼Œå¦‚æœè¾“å…¥çš„urlå‚æ•°æ²¡æœ‰ `http://` å‰ç¼€çš„è¯ï¼Œä¸ºè¿™ä¸ªurlåŠ ä¸Šè¯¥å‰ç¼€ã€‚ä½ å¯èƒ½ä¼šç”¨åˆ°strings.HasPrefixè¿™ä¸ªå‡½æ•°ã€‚

```
 if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
            url = "http://" + url
        }
```

`func HasPrefix(s, prefix string) bool` åˆ¤æ–­sæ˜¯å¦ä»¥prefixå¼€å¤´

**ç»ƒä¹  1.9ï¼š** ä¿®æ”¹fetchæ‰“å°å‡ºHTTPåè®®çš„çŠ¶æ€ç ï¼Œå¯ä»¥ä»resp.Statuså˜é‡å¾—åˆ°è¯¥çŠ¶æ€ç ã€‚

```
        //æ‰“å°çŠ¶æ€ç ï¼Œä¸éœ€è¦åœ¨å¼‚å¸¸æµç¨‹é‡Œæ‰“å°ï¼Œå› ä¸ºerræ—¶resp == nil
        fmt.Fprintf(os.Stdout, "status code: %s\n\n", resp.Status)
```

å®Œæ•´ä»£ç 

```
// Fetch prints the content found at a URL.
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
    "strings"
)

func main() {
    for _, url := range os.Args[1:] {
    	if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
    		url = "http://" + url
    	}
        resp, err := http.Get(url)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
            os.Exit(1)
        }
      
        defer resp.Body.Close()
        //æ‰“å°çŠ¶æ€ç ï¼Œä¸éœ€è¦åœ¨å¼‚å¸¸æµç¨‹é‡Œæ‰“å°ï¼Œå› ä¸ºerræ—¶resp == nil
        fmt.Fprintf(os.Stdout, "status code: %s\n\n", resp.Status)

        _, err = io.Copy(os.Stdout, resp.Body)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: Copy faild %s: %v\n", url, err)
            os.Exit(1)
        }
        
    }
}

```

#### 1.6.å¹¶å‘è·å–å¤šä¸ªurl

*Goè¯­è¨€æœ€æœ‰æ„æ€å¹¶ä¸”æœ€æ–°å¥‡çš„ç‰¹æ€§å°±æ˜¯å¯¹å¹¶å‘ç¼–ç¨‹çš„æ”¯æŒã€‚å¹¶å‘ç¼–ç¨‹æ˜¯ä¸€ä¸ªå¤§è¯é¢˜ï¼Œåœ¨ç¬¬å…«ç« å’Œç¬¬ä¹ç« ä¸­ä¼šä¸“é—¨è®²åˆ°ã€‚è¿™é‡Œæˆ‘ä»¬åªæµ…å°è¾„æ­¢åœ°æ¥ä½“éªŒä¸€ä¸‹Goè¯­è¨€é‡Œçš„goroutineå’Œchannelã€‚*

```go
// Fetchall fetches URLs in parallel and reports their times and sizes.
package main

import (
    "fmt"
    "io"
    "io/ioutil"
    "net/http"
    "os"
    "time"
)

func main() {
    start := time.Now()
    ch := make(chan string)
    for _, url := range os.Args[1:] {
        go fetch(url, ch) // start a goroutine
    }
    for range os.Args[1:] {
        fmt.Println(<-ch) // receive from channel ch
    }
    fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}

func fetch(url string, ch chan<- string) {
    start := time.Now()
    resp, err := http.Get(url)
    if err != nil {
        ch <- fmt.Sprint(err) // send to channel ch
        return
    }
    nbytes, err := io.Copy(ioutil.Discard, resp.Body)
    resp.Body.Close() // don't leak resources
    if err != nil {
        ch <- fmt.Sprintf("while reading %s: %v", url, err)
        return
    }
    secs := time.Since(start).Seconds()
    ch <- fmt.Sprintf("%.2fs  %7d  %s", secs, nbytes, url)
}

```

`go fetch(url, ch) // start a goroutine`

å¯åŠ¨ä¸€ä¸ªæ–°çš„goroutineæ‰§è¡Œfetch(url, ch)å‡½æ•°ï¼Œæ¯ä¸ªURLéƒ½åœ¨ç‹¬ç«‹çš„çº¿ç¨‹ä¸­è¯·æ±‚ï¼Œmainçº¿ç¨‹ä¸ä¼šé˜»å¡ï¼Œä¼šç»§ç»­æ‰§è¡Œã€‚

*goroutineæ˜¯ä¸€ç§å‡½æ•°çš„å¹¶å‘æ‰§è¡Œæ–¹å¼ï¼Œè€Œchannelæ˜¯ç”¨æ¥åœ¨goroutineä¹‹é—´è¿›è¡Œå‚æ•°ä¼ é€’ã€‚mainå‡½æ•°æœ¬èº«ä¹Ÿè¿è¡Œåœ¨ä¸€ä¸ªgoroutineä¸­*

` ch := make(chan string)`

åˆ›å»ºä¸€ä¸ªchannelï¼ˆé€šé“ï¼‰ï¼Œè®©goroutineæŠŠç»“æœä¼ å›ä¸»goroutine

`ch <- fmt.Sprintf("%.2fs  %7d  %s", secs, nbytes, url)`

fetchå‡½æ•°æŠŠæ ¼å¼åŒ–å¥½çš„å­—ç¬¦ä¸²å‘é€åˆ°é€šé“chï¼Œè¿™ä¸ªè¿‡ç¨‹ä¼š**é˜»å¡å‘é€æ–¹**ï¼Œç›´åˆ°æœ‰æ¥æ”¶æ–¹ï¼ˆmain å‡½æ•°ï¼‰ä» `ch` ä¸­è¯»å–ã€‚

    for range os.Args[1:] {
        fmt.Println(<-ch) // receive from channel ch
    }

ä¸»çº¿ç¨‹ä¾æ¬¡æ¥æ”¶å¹¶æ‰“å°

æ€»ä½“æµç¨‹

```
main()
â”‚
â”œâ”€â”€ åˆ›å»º channel ch
â”‚
â”œâ”€â”€ å¯åŠ¨ N ä¸ª goroutine å¹¶å‘ fetch(url, ch)
â”‚      â””â”€â”€ æ¯ä¸ª fetch æ‰§è¡Œ http.Get
â”‚      â””â”€â”€ å®Œæˆåé€šè¿‡ ch <- result æŠŠç»“æœå‘å›ä¸»çº¿ç¨‹
â”‚
â”œâ”€â”€ ä¸»çº¿ç¨‹é€šè¿‡ <-ch è¯»å–æ¯ä¸ªç»“æœï¼ˆå…± N æ¬¡ï¼‰
â”‚
â””â”€â”€ æ‰“å°æ€»è€—æ—¶

```

**ç»ƒä¹  1.10ï¼š** æ‰¾ä¸€ä¸ªæ•°æ®é‡æ¯”è¾ƒå¤§çš„ç½‘ç«™ï¼Œç”¨æœ¬å°èŠ‚ä¸­çš„ç¨‹åºè°ƒç ”ç½‘ç«™çš„ç¼“å­˜ç­–ç•¥ï¼Œå¯¹æ¯ä¸ªURLæ‰§è¡Œä¸¤éè¯·æ±‚ï¼ŒæŸ¥çœ‹ä¸¤æ¬¡æ—¶é—´æ˜¯å¦æœ‰è¾ƒå¤§çš„å·®åˆ«ï¼Œå¹¶ä¸”æ¯æ¬¡è·å–åˆ°çš„å“åº”å†…å®¹æ˜¯å¦ä¸€è‡´ï¼Œä¿®æ”¹æœ¬èŠ‚ä¸­çš„ç¨‹åºï¼Œå°†å“åº”ç»“æœè¾“å‡ºåˆ°æ–‡ä»¶ï¼Œä»¥ä¾¿äºè¿›è¡Œå¯¹æ¯”ã€‚

```go
// Fetchall fetches URLs in parallel and reports their times and sizes.
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
    "time"
    "strings"
)

func main() {
    start := time.Now()
    ch := make(chan string)

    for _, url := range os.Args[1:] {
        go fetch(url, ch) // start a goroutine
    }
    for range os.Args[1:] {
        fmt.Println(<-ch) // receive from channel ch
    }

    fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}

func fetch(url string, ch chan<-- string) {
    start := time.Now()
    resp, err := http.Get(url)
    if err != nil {
        ch <- fmt.Sprint(err) // send to channel ch
        return
    }
    filename := sanitizeFilename(url) + ".html"
    file, err := os.Create(filename)
    if err != nil {
        ch <- fmt.Sprintf("create file error for %s: %v", url, err)
        return
    }
    defer file.Close()

    // å°† body å†…å®¹å†™å…¥æ–‡ä»¶ï¼ŒåŒæ—¶ç»Ÿè®¡å¤§å°
    nbytes, err := io.Copy(file, resp.Body)
    if err != nil {
        ch <- fmt.Sprintf("write error for %s: %v", url, err)
        return
    }

    secs := time.Since(start).Seconds()
    ch <- fmt.Sprintf("%.2fs  %7d  %s  -> saved to %s", secs, nbytes, url, filename)
}

// sanitizeFilename å°† URL ç®€åŒ–ä¸ºåˆæ³•æ–‡ä»¶å
func sanitizeFilename(url string) string {
    url = strings.TrimPrefix(url, "http://")
    url = strings.TrimPrefix(url, "https://")
    url = strings.ReplaceAll(url, "/", "_")
    return url
}

```

ä¸»è¦ä¿®æ”¹fetchå‡½æ•°ï¼Œå°†Bodyå†…å®¹å†™å…¥æ–‡ä»¶

```go
â¯ go run ./fetchall.go https://golang-china.github.io/gopl-zh/
0.39s    30164  https://golang-china.github.io/gopl-zh/  -> saved to golang-china.github.io_gopl-zh_.html
0.39s elapsed
â¯ mv golang-china.github.io_gopl-zh_.html a.html
â¯ go run ./fetchall.go https://golang-china.github.io/gopl-zh/
0.22s    30164  https://golang-china.github.io/gopl-zh/  -> saved to golang-china.github.io_gopl-zh_.html
0.22s elapsed
â¯ diff a.html golang-china.github.io_gopl-zh_.html
```

**ç»ƒä¹  1.11ï¼š** åœ¨fetchallä¸­å°è¯•ä½¿ç”¨é•¿ä¸€äº›çš„å‚æ•°åˆ—è¡¨ï¼Œæ¯”å¦‚ä½¿ç”¨åœ¨alexa.comçš„ä¸Šç™¾ä¸‡ç½‘ç«™é‡Œæ’åé å‰çš„ã€‚å¦‚æœä¸€ä¸ªç½‘ç«™æ²¡æœ‰å›åº”ï¼Œç¨‹åºå°†é‡‡å–æ€æ ·çš„è¡Œä¸ºï¼Ÿï¼ˆSection8.9 æè¿°äº†åœ¨è¿™ç§æƒ…å†µä¸‹çš„åº”å¯¹æœºåˆ¶ï¼‰ã€‚

```go
 client := http.Client{
        Timeout: 5 * time.Second,
    }

    resp, err := client.Get(url)
```

åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œè®¾ç½®è¶…æ—¶æ—¶é—´ã€

é™åˆ¶å¹¶å‘æ•°é‡ã€è®°å½•æ—¥å¿—ï¼ˆåç»­å†å°è¯•ï¼‰

---

Qï¼šæœ¬å°ç»“ç”¨åˆ°çš„å‡ ä¸ªprintæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

Aï¼š

| å‡½æ•°      | ç”¨é€”                      | æ˜¯å¦æ ¼å¼åŒ– | æ˜¯å¦æ¢è¡Œ | æ˜¯å¦è¿”å›å­—ç¬¦ä¸² |
| --------- | ------------------------- | ---------- | -------- | -------------- |
| `Sprintf` | æ„é€ å­—ç¬¦ä¸²ï¼Œä¸æ‰“å°        | âœ…          | âŒ        | âœ…              |
| `Printf`  | æ ¼å¼åŒ–å¹¶æ‰“å°              | âœ…          | âŒ        | âŒ              |
| `Println` | ç›´æ¥æ‰“å°ï¼ˆè‡ªåŠ¨ç©ºæ ¼+æ¢è¡Œï¼‰ | âŒ          | âœ…        | âŒ              |

---

#### 1.7.webæœåŠ¡



**ç»ƒä¹  1.12ï¼š** ä¿®æ”¹LissajouræœåŠ¡ï¼Œä»URLè¯»å–å˜é‡ï¼Œæ¯”å¦‚ä½ å¯ä»¥è®¿é—® http://localhost:8000/?cycles=20 è¿™ä¸ªURLï¼Œè¿™æ ·è®¿é—®å¯ä»¥å°†ç¨‹åºé‡Œçš„cyclesé»˜è®¤çš„5ä¿®æ”¹ä¸º20ã€‚å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å­—å¯ä»¥è°ƒç”¨strconv.Atoiå‡½æ•°ã€‚ä½ å¯ä»¥åœ¨godocé‡ŒæŸ¥çœ‹strconv.Atoiçš„è¯¦ç»†è¯´æ˜ã€‚

```go
// Server1 is a minimal "echo" server.
package main

import (
    "image"
    "image/color"
    "image/gif"
    "io"
    "math"
    "math/rand"
	  "net/http"
    "log"
    "fmt"
    "strconv"
)


var palette = []color.Color{
    color.White,                        // èƒŒæ™¯è‰²
    color.RGBA{0xFF, 0x00, 0x00, 0xFF}, // çº¢
    color.RGBA{0xFF, 0xA5, 0x00, 0xFF}, // æ©™
    color.RGBA{0xFF, 0xFF, 0x00, 0xFF}, // é»„
    color.RGBA{0x00, 0xFF, 0x00, 0xFF}, // ç»¿
    color.RGBA{0x00, 0x00, 0xFF, 0xFF}, // è“
    color.RGBA{0x4B, 0x00, 0x82, 0xFF}, // é›
    color.RGBA{0x8B, 0x00, 0xFF, 0xFF}, // ç´«
}

const (
    whiteIndex = 0 // first color in palette
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
    r.ParseForm() // è§£æURLä¸­çš„å‚æ•°
    cycles := 5
    //è·å–cycelå€¼
    if val := r.Form.Get("cycles"); val != "" {
    //å­—ç¬¦ä¸²è½¬æ¢in t
            if parsed, err := strconv.Atoi(val); err == nil {
                cycles = parsed
            }
        }

    lissajous(w, cycles)
})
    log.Fatal(http.ListenAndServe("localhost:8000", nil))
}

//ä¿®æ”¹å‡½æ•°ç­¾å
func lissajous(out io.Writer, cycles int) {
    const (
        res     = 0.001 // angular resolution
        size    = 100   // image canvas covers [-size..+size]
        nframes = 64    // number of animation frames
        delay   = 8     // delay between frames in 10ms units
    )

    freq := rand.Float64() * 3.0 // relative frequency of y oscillator
    anim := gif.GIF{LoopCount: nframes}
    phase := 0.0 // phase difference
    for i := 0; i < nframes; i++ {
        rect := image.Rect(0, 0, 2*size+1, 2*size+1)
        img := image.NewPaletted(rect, palette)

        colorIndex := uint8(i%(len(palette)-1) + 1)
				//è¿›è¡Œæµ®ç‚¹æ•°è®¡ç®—ï¼Œè½¬æ¢cyclesç±»å‹
        for t := 0.0; t < float64(cycles)*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), colorIndex)
        }
        phase += 0.1
        anim.Delay = append(anim.Delay, delay)
        anim.Image = append(anim.Image, img)
    }
    gif.EncodeAll(out, &anim) // NOTE: ignoring encoding errors
}

```

#### 1.8.æœ¬ç« è¦ç‚¹

*æœ¬ç« å¯¹Goè¯­è¨€åšäº†ä¸€äº›ä»‹ç»ï¼ŒGoè¯­è¨€å¾ˆå¤šæ–¹é¢åœ¨æœ‰é™çš„ç¯‡å¹…ä¸­æ— æ³•è¦†ç›–åˆ°ã€‚æœ¬èŠ‚ä¼šæŠŠæ²¡æœ‰è®²åˆ°çš„å†…å®¹ä¹Ÿåšä¸€äº›ç®€å•çš„ä»‹ç»ï¼Œè¿™æ ·è¯»è€…åœ¨è¯»åˆ°å®Œæ•´çš„å†…å®¹ä¹‹å‰ï¼Œå¯ä»¥æœ‰ä¸ªç®€å•çš„å°è±¡ã€‚*

***æ§åˆ¶æµï¼š** åœ¨æœ¬ç« æˆ‘ä»¬åªä»‹ç»äº†ifæ§åˆ¶å’Œforï¼Œä½†æ˜¯æ²¡æœ‰æåˆ°switchå¤šè·¯é€‰æ‹©ã€‚è¿™é‡Œæ˜¯ä¸€ä¸ªç®€å•çš„switchçš„ä¾‹å­ï¼š*

```
switch coinflip() {
case "heads":
    heads++
case "tails":
    tails++
default:
    fmt.Println("landed on edge!")
}
```

*åœ¨æ¯ä¸€ä¸ªå‡½æ•°ä¹‹å‰å†™ä¸€ä¸ªè¯´æ˜å‡½æ•°è¡Œä¸ºçš„æ³¨é‡Šä¹Ÿæ˜¯ä¸€ä¸ªå¥½ä¹ æƒ¯ã€‚è¿™äº›æƒ¯ä¾‹å¾ˆé‡è¦ï¼Œå› ä¸ºè¿™äº›å†…å®¹ä¼šè¢«åƒgodocè¿™æ ·çš„å·¥å…·æ£€æµ‹åˆ°ï¼Œå¹¶ä¸”åœ¨æ‰§è¡Œå‘½ä»¤æ—¶æ˜¾ç¤ºè¿™äº›æ³¨é‡Š*

*å¤šè¡Œæ³¨é‡Šå¯ä»¥ç”¨ `/* ... */` æ¥åŒ…è£¹ï¼Œå’Œå…¶å®ƒå¤§å¤šæ•°è¯­è¨€ä¸€æ ·ã€‚*

