# Goè¯­è¨€è‡ªå­¦ç¬”è®°

| æ—¥æœŸ       | å†…å®¹                  |
| ---------- | --------------------- |
| 2025.07.03 | è¯‘è€…åºã€å‰è¨€ã€1.1 1.2 |
| 2025.07.04 | 1.3                   |
| 2025.07.07 | 1.4ã€1.5              |
| 2025.07.09 | 1.6ã€1.7              |
| 2025.07.15 | 2                     |

## ä¸€ã€ä¸ºä»€ä¹ˆè¦å­¦

  ä¸­å›½æœ‰å¥å¤è¯ï¼Œä¸‰æ€è€Œåè¡Œã€‚è‹±æ–‡å°±æ˜¯one, two ,three , Go.æ‰€ä»¥ä¸‰æ€åè¦å­¦Goï¼ˆå¼€ä¸ªç©ç¬‘ï¼‰ã€‚

ä»¥ä¸‹å†…å®¹æºè‡ªäº’è”ç½‘ï¼š

  Golang â€”â€” è®©ä½ ç”¨å†™Pythonä»£ç çš„å¼€å‘æ•ˆç‡ç¼–å†™å‡ºC++ä»£ç çš„æ€§èƒ½ã€‚

  Goè¯­è¨€(æˆ–Golang)æ˜¯Golanguageçš„ç®€ç§°ï¼ŒGoæ˜¯Googleçš„Ken Thompsonï¼ŒRob Pikeä»¥åŠRobert Griesemerå¼€å‘çš„ä¸€ç§é™æ€å¼ºç±»å‹ã€ç¼–è¯‘å¹¶å‘å‹è¯­è¨€ã€‚

  å­¦ä¹ Goè¯­è¨€çš„ä¸»è¦åŸå› æ˜¯å…¶åœ¨å¹¶å‘ç¼–ç¨‹ã€ç³»ç»Ÿç¼–ç¨‹å’Œäº‘åŸç”Ÿé¢†åŸŸçš„é«˜æ•ˆæ€§å’Œç®€æ´æ€§ã€‚Goè¯­è¨€ç‰¹åˆ«é€‚åˆæ„å»ºé«˜æ€§èƒ½çš„ç½‘ç»œæœåŠ¡ã€åˆ†å¸ƒå¼ç³»ç»Ÿã€äº‘è®¡ç®—åŸºç¡€è®¾æ–½å’Œå®¹å™¨åŒ–åº”ç”¨ã€‚æ­¤å¤–ï¼ŒGoè¯­è¨€çš„å­¦ä¹ æ›²çº¿ç›¸å¯¹å¹³ç¼“ï¼Œå¯¹äºæœ‰ä¸€å®šç¼–ç¨‹ç»éªŒçš„å¼€å‘è€…æ¥è¯´ï¼Œä¸Šæ‰‹æ¯”è¾ƒå®¹æ˜“ã€‚

   æ­¤å¤–åœ¨å·¥ä½œä¸­æ¥è§¦åˆ°çš„è®¸å¤šä¼˜ç§€çš„äº‘åŸç”Ÿåº”ç”¨å¦‚Dockerï¼ŒKubernetesï¼Œetcdï¼ŒPrometheusç­‰éƒ½ä½¿ç”¨Goè¯­è¨€å¼€å‘ï¼Œæ›´å¼•å‘äº†æˆ‘çš„å…´è¶£ï¼Œæ‰€ä»¥å®šä¸€ä¸ªç›®æ ‡ï¼Œå¸Œæœ›èƒ½å­¦ä¹ æŒæ¡Goè¯­è¨€ï¼Œå¹¶å°è¯•åœ¨è‡ªå·±å–œæ¬¢çš„åŸºäºgoå¼€å‘çš„é¡¹ç›®ä¸­æäº¤è´¡çŒ®ã€‚

## äºŒã€å­¦ä¹ è®°å½•

åç»­å­¦ä¹ åŸºäº[ã€ŠThe Go Programming Languageã€‹ï¼ˆGoè¯­è¨€åœ£ç»ä¸­æ–‡ç‰ˆï¼‰](https://gopl-zh.github.io/index.html)è¿›è¡Œï¼Œè®°å½•ä¸ªäººè§‰å¾—ä¹¦ä¸­å…³é”®å’Œæœ‰æ„æ€çš„å†…å®¹ã€ä»£ç ç»ƒä¹ ç­‰ã€‚

### **å‰è¨€**

åç»­å‚è€ƒå¼•ç”¨ä¼šå°½é‡è¡¨æ˜ï¼Œ*â€œæ–œä½“â€*ä»£è¡¨ç›´æ¥å¼•ç”¨ä¹¦ä¸­å†…å®¹ï¼Œå…¶ä»–å¼•è‡ªäº’è”ç½‘çš„å†…å®¹ä¼šç‰¹åˆ«æ ‡æ³¨ã€‚

---

*â€œGoè¯­è¨€æœ‰æ—¶å€™è¢«æè¿°ä¸ºâ€œç±»Cè¯­è¨€â€ï¼Œæˆ–è€…æ˜¯â€œ21ä¸–çºªçš„Cè¯­è¨€â€ã€‚â€*

*â€œæ­£å¦‚[Rob Pike](http://genius.cat-v.org/rob-pike/)æ‰€è¯´ï¼Œâ€œè½¯ä»¶çš„å¤æ‚æ€§æ˜¯ä¹˜æ³•çº§ç›¸å…³çš„â€ï¼Œé€šè¿‡å¢åŠ ä¸€ä¸ªéƒ¨åˆ†çš„å¤æ‚æ€§æ¥ä¿®å¤é—®é¢˜é€šå¸¸å°†æ…¢æ…¢åœ°å¢åŠ å…¶ä»–éƒ¨åˆ†çš„å¤æ‚æ€§ã€‚é€šè¿‡å¢åŠ åŠŸèƒ½ã€é€‰é¡¹å’Œé…ç½®æ˜¯ä¿®å¤é—®é¢˜çš„æœ€å¿«çš„é€”å¾„ï¼Œä½†æ˜¯è¿™å¾ˆå®¹æ˜“è®©äººå¿˜è®°ç®€æ´çš„å†…æ¶µï¼Œå³ä»é•¿è¿œæ¥çœ‹ï¼Œç®€æ´ä¾ç„¶æ˜¯å¥½è½¯ä»¶çš„å…³é”®å› ç´ ã€‚â€*

---

æœ¬äººå­¦ç”Ÿé˜¶æ®µç–äºå­¦ä¹ ï¼Œæ°´å¹³æœ‰é™ï¼Œå­¦ä¹ è¿‡ç¨‹ä¸­çš„ä¸€äº›å¥‡å¥‡æ€ªæ€ªçš„ç–‘é—®ä¼šè®°å½•æˆQ&Açš„å½¢å¼ï¼ŒAä¸€èˆ¬æ˜¯ä»AIé‚£å¾—åˆ°çš„ç­”æ¡ˆã€‚

---

Qï¼š666

Aï¼šğŸ˜„ ä½ å¤ªå®¢æ°”äº†ï¼

---

**ç¯å¢ƒå®‰è£…**

https://go.dev/doc/install, é€‰æ‹©å¯¹åº”ç‰ˆæœ¬å®‰è£…

```shell
â¯ go version
go version go1.24.4 darwin/arm64
```

åé¢çš„æ ‡é¢˜å¯¹åº”ä¹¦ä¸­æ ‡é¢˜

### 1.<span id="jump1">å…¥é—¨</span>

#### 1.1.Hello, World

â€œ*æˆ‘ä»¬ä»¥ç°å·²æˆä¸ºä¼ ç»Ÿçš„â€œhello worldâ€æ¡ˆä¾‹æ¥å¼€å§‹å§ï¼Œè¿™ä¸ªä¾‹å­é¦–æ¬¡å‡ºç°äº 1978 å¹´å‡ºç‰ˆçš„ C è¯­è¨€åœ£ç» ã€ŠThe C Programming Languageã€‹*â€

```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, world")
}
```

```
â¯ vi helloworld.go
â¯ go run helloworld.go
Hello, world
```

---

Qï¼šgo run helloworld.go è¿è¡Œé€Ÿåº¦æ…¢ï¼ŒåŒæ ·çš„å†™ä¸€ä¸ª.pyè„šæœ¬æ‰§è¡Œé€Ÿåº¦è¦å¿«nå€ï¼Ÿ

Aï¼šå…³é”®åŒºåˆ«ï¼šGo æ˜¯ç¼–è¯‘å‹è¯­è¨€ï¼ŒPython æ˜¯è§£é‡Šå‹è¯­è¨€ã€‚pyç›´æ¥è°ƒç”¨è§£é‡Šå™¨æ‰§è¡Œ `.py` æ–‡ä»¶ï¼Œä¸éœ€è¦ç¼–è¯‘ï¼Œå‡ ä¹æ˜¯**å³ç‚¹å³è¿è¡Œ**ã€‚`go run`å®é™…ä¸Šæ˜¯ä¸¤æ­¥è¿‡ç¨‹ï¼šå…ˆ **ä¸´æ—¶ç¼–è¯‘** æˆäºŒè¿›åˆ¶æ–‡ä»¶ï¼ˆæ”¾åœ¨ä¸´æ—¶ç›®å½•ä¸‹ï¼Œå¦‚ `/tmp`ï¼‰ç„¶åå†æ‰§è¡Œè¿™ä¸ªä¸´æ—¶äºŒè¿›åˆ¶æ–‡ä»¶ã€‚

```
â¯ date;go run helloworld.go;date
2025å¹´ 7æœˆ 3æ—¥ æ˜ŸæœŸå›› 11æ—¶35åˆ†15ç§’ CST
Hello, world
2025å¹´ 7æœˆ 3æ—¥ æ˜ŸæœŸå›› 11æ—¶35åˆ†16ç§’ CST
â¯ go build helloworld.go
â¯ ls
helloworld    helloworld.go
â¯ date;./helloworld;date
2025å¹´ 7æœˆ 3æ—¥ æ˜ŸæœŸå›› 11æ—¶35åˆ†39ç§’ CST
Hello, world
2025å¹´ 7æœˆ 3æ—¥ æ˜ŸæœŸå›› 11æ—¶35åˆ†39ç§’ CST
```

å¯ä»¥çœ‹åˆ°è¿è¡Œç¼–è¯‘åçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¼šå¿«å¾ˆå¤š

---



*Go è¯­è¨€çš„ä»£ç é€šè¿‡**åŒ…**ï¼ˆpackageï¼‰ç»„ç»‡ï¼ŒåŒ…ç±»ä¼¼äºå…¶å®ƒè¯­è¨€é‡Œçš„åº“ï¼ˆlibrariesï¼‰æˆ–è€…æ¨¡å—ï¼ˆmodulesï¼‰ã€‚ä¸€ä¸ªåŒ…ç”±ä½äºå•ä¸ªç›®å½•ä¸‹çš„ä¸€ä¸ªæˆ–å¤šä¸ª `.go` æºä»£ç æ–‡ä»¶ç»„æˆï¼Œç›®å½•å®šä¹‰åŒ…çš„ä½œç”¨ã€‚æ¯ä¸ªæºæ–‡ä»¶éƒ½ä»¥ä¸€æ¡ `package` å£°æ˜è¯­å¥å¼€å§‹ï¼Œè¿™ä¸ªä¾‹å­é‡Œå°±æ˜¯ `package main`ï¼Œè¡¨ç¤ºè¯¥æ–‡ä»¶å±äºå“ªä¸ªåŒ…ï¼Œç´§è·Ÿç€ä¸€ç³»åˆ—å¯¼å…¥ï¼ˆimportï¼‰çš„åŒ…ï¼Œä¹‹åæ˜¯å­˜å‚¨åœ¨è¿™ä¸ªæ–‡ä»¶é‡Œçš„ç¨‹åºè¯­å¥ã€‚*

*Go è¯­è¨€ä¸éœ€è¦åœ¨è¯­å¥æˆ–è€…å£°æ˜çš„æœ«å°¾æ·»åŠ åˆ†å·ï¼Œé™¤éä¸€è¡Œä¸Šæœ‰å¤šæ¡è¯­å¥ã€‚*

*Go è¯­è¨€åœ¨ä»£ç æ ¼å¼ä¸Šé‡‡å–äº†å¾ˆå¼ºç¡¬çš„æ€åº¦ã€‚`gofmt`å·¥å…·æŠŠä»£ç æ ¼å¼åŒ–ä¸ºæ ‡å‡†æ ¼å¼*

---

Qï¼šgo get/install è®¿é—®proxy.golang.orgè¶…æ—¶çš„è§£å†³æ–¹å¼ï¼š

```
go env -w GOPROXY=https://goproxy.cn
```

```
â¯ go install  golang.org/x/tools/cmd/goimports@latest
go: downloading golang.org/x/tools v0.34.0
go: downloading golang.org/x/mod v0.25.0
go: downloading golang.org/x/sync v0.15.0
```

---



#### 1.2.å‘½ä»¤è¡Œå‚æ•°

```go
// Echo2 prints its command-line arguments.
package main

import (
    "fmt"
    "os"
)

func main() {
    s, sep := "", ""
    for _, arg := range os.Args[1:] {
        s += sep + arg
        sep = " "
    }
    fmt.Println(s)
}

```

*ç¬¦å· `:=` æ˜¯ çŸ­å˜é‡å£°æ˜ï¼ˆshort variable declarationï¼‰çš„ä¸€éƒ¨åˆ†ï¼Œè¿™æ˜¯å®šä¹‰ä¸€ä¸ªæˆ–å¤šä¸ªå˜é‡å¹¶æ ¹æ®å®ƒä»¬çš„åˆå§‹å€¼ä¸ºè¿™äº›å˜é‡èµ‹äºˆé€‚å½“ç±»å‹çš„è¯­å¥ã€‚*

*Go è¯­è¨€åªæœ‰ `for` å¾ªç¯è¿™ä¸€ç§å¾ªç¯è¯­å¥ã€‚`for` å¾ªç¯æœ‰å¤šç§å½¢å¼ï¼Œå…¶ä¸­ä¸€ç§å¦‚ä¸‹æ‰€ç¤ºï¼š*

```go
for initialization; condition; post {
    // zero or more statements
}
```



**ç»ƒä¹  1.1ï¼š** ä¿®æ”¹ `echo` ç¨‹åºï¼Œä½¿å…¶èƒ½å¤Ÿæ‰“å° `os.Args[0]`ï¼Œå³è¢«æ‰§è¡Œå‘½ä»¤æœ¬èº«çš„åå­—ã€‚

**ç»ƒä¹  1.2ï¼š** ä¿®æ”¹ `echo` ç¨‹åºï¼Œä½¿å…¶æ‰“å°æ¯ä¸ªå‚æ•°çš„ç´¢å¼•å’Œå€¼ï¼Œæ¯ä¸ªä¸€è¡Œã€‚

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	for i, arg := range os.Args {
		if i == 0 {
			fmt.Println("os.Args[0]= ", arg)
		}
		fmt.Println(i, arg)
	}
}
```

**ç»ƒä¹  1.3ï¼š** åšå®éªŒæµ‹é‡æ½œåœ¨ä½æ•ˆçš„ç‰ˆæœ¬å’Œä½¿ç”¨äº† `strings.Join` çš„ç‰ˆæœ¬çš„è¿è¡Œæ—¶é—´å·®å¼‚ã€‚

```go
// compare.
package main

import (
	"fmt"
	"os"
	"strings"
	"time"
)

func main() {
	now := time.Now()
	var s, sep string
	for i := 1; i < len(os.Args); i++ {
		s += sep + os.Args[i]
		sep = " "
	}
	fmt.Println(s)
	end := time.Now()
	fmt.Println("cost time:", end.Sub(now))

	n_now := time.Now()
	fmt.Println(strings.Join(os.Args[1:], " "))
	n_end := time.Now()
	fmt.Println("Join funcation cost time:", n_end.Sub(n_now))
}
```

#### 1.3.æŸ¥æ‰¾é‡å¤çš„è¡Œ

æœ¬å°ç»“ä»¥æŸ¥æ‰¾é‡å¤è¡Œä¸ºæ¡ˆä¾‹ï¼ŒæåŠäº†å¤šç§è¯»å–æ–¹å¼ï¼ˆæ ‡å‡†è¾“å…¥ã€æ–‡ä»¶é€è¡Œè¯»å–ã€ä¸€æ¬¡æ€§è¯»å–ï¼‰ã€`map`ã€`Printf`ã€å‚æ•°ä¼ é€’ã€é”™è¯¯å¤„ç†ç­‰å†…å®¹ï¼Œæœ‰ä¸€ä¸ªç»ƒä¹ é¢˜ã€‚

ä»æ ‡å‡†è¾“å…¥è¯»å–å†…å®¹

```go
// Dup1 prints the text of each line that appears more than
// once in the standard input, preceded by its count.
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
  //åˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²åˆ°æ•´æ•°çš„ mapï¼Œè®°å½•æ¯è¡Œæ–‡æœ¬å‡ºç°çš„æ¬¡æ•°ã€‚
    counts := make(map[string]int)
  //åˆ›å»ºä¸€ä¸ª Scanner å¯¹è±¡ï¼Œä»æ ‡å‡†è¾“å…¥è¯»å–æ–‡æœ¬ï¼ˆé€è¡Œè¯»å–ï¼‰ã€‚
    input := bufio.NewScanner(os.Stdin)
  /*input.Scan() ä¼šè¯»å–ä¸‹ä¸€è¡Œå†…å®¹ï¼Œç›´åˆ°é‡åˆ° EOFï¼ˆç»“æŸè¾“å…¥ï¼‰ã€‚
		input.Text() è¿”å›å½“å‰è¡Œçš„å­—ç¬¦ä¸²ã€‚
		æ¯è¯»å–ä¸€è¡Œï¼Œå°±å°†è¯¥è¡Œä½œä¸ºé”®åŠ å…¥ map å¹¶é€’å¢æ¬¡æ•°ã€‚
	*/
    for input.Scan() {
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
  
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}

```

ä»æ ‡å‡†è¾“å…¥è¯»å–`bufio.NewScanner(os.Stdin)`

*å†…ç½®å‡½æ•° `make` åˆ›å»ºç©º `map`*

*åŸºäº `range` çš„å¾ªç¯ï¼Œå¹¶åœ¨ `counts` è¿™ä¸ª `map` ä¸Šè¿­ä»£ã€‚è·Ÿä¹‹å‰ç±»ä¼¼ï¼Œæ¯æ¬¡è¿­ä»£å¾—åˆ°ä¸¤ä¸ªç»“æœï¼Œé”®å’Œå…¶åœ¨ `map` ä¸­å¯¹åº”çš„å€¼ã€‚**`map` çš„è¿­ä»£é¡ºåºå¹¶ä¸ç¡®å®š**ï¼Œä»å®è·µæ¥çœ‹ï¼Œè¯¥é¡ºåºéšæœºï¼Œæ¯æ¬¡è¿è¡Œéƒ½ä¼šå˜åŒ–ã€‚è¿™ç§è®¾è®¡æ˜¯æœ‰æ„ä¸ºä¹‹çš„ï¼Œ*

*ç±»ä¼¼äº C æˆ–å…¶å®ƒè¯­è¨€é‡Œçš„ `printf` å‡½æ•°ï¼Œ`fmt.Printf` å‡½æ•°å¯¹ä¸€äº›è¡¨è¾¾å¼äº§ç”Ÿæ ¼å¼åŒ–è¾“å‡ºã€‚*

*`Printf` æœ‰ä¸€å¤§å †è¿™ç§è½¬æ¢ï¼ŒGoç¨‹åºå‘˜ç§°ä¹‹ä¸ºåŠ¨è¯ï¼ˆverbï¼‰ã€‚ä¸‹é¢çš„è¡¨æ ¼è™½ç„¶è¿œä¸æ˜¯å®Œæ•´çš„è§„èŒƒï¼Œä½†å±•ç¤ºäº†å¯ç”¨çš„å¾ˆå¤šç‰¹æ€§ï¼š*

```text
%d          åè¿›åˆ¶æ•´æ•°
%x, %o, %b  åå…­è¿›åˆ¶ï¼Œå…«è¿›åˆ¶ï¼ŒäºŒè¿›åˆ¶æ•´æ•°ã€‚
%f, %g, %e  æµ®ç‚¹æ•°ï¼š 3.141593 3.141592653589793 3.141593e+00
%t          å¸ƒå°”ï¼štrueæˆ–false
%c          å­—ç¬¦ï¼ˆruneï¼‰ (Unicodeç ç‚¹)
%s          å­—ç¬¦ä¸²
%q          å¸¦åŒå¼•å·çš„å­—ç¬¦ä¸²"abc"æˆ–å¸¦å•å¼•å·çš„å­—ç¬¦'c'
%v          å˜é‡çš„è‡ªç„¶å½¢å¼ï¼ˆnatural formatï¼‰
%T          å˜é‡çš„ç±»å‹
%%          å­—é¢ä¸Šçš„ç™¾åˆ†å·æ ‡å¿—ï¼ˆæ— æ“ä½œæ•°ï¼‰
åˆ¶è¡¨ç¬¦\tå’Œæ¢è¡Œç¬¦\n
```

ä»æ–‡ä»¶ä¸­è¯»å–

```go
// Dup2 prints the count and text of lines that appear more than once
// in the input.  It reads from stdin or from a list of named files.
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    counts := make(map[string]int)
    files := os.Args[1:]
    if len(files) == 0 {
        countLines(os.Stdin, counts)
    } else {
        for _, arg := range files {
            f, err := os.Open(arg)
            if err != nil {
                fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
                continue
            }
            countLines(f, counts)
            f.Close()
        }
    }
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}
	
func countLines(f *os.File, counts map[string]int) {
    input := bufio.NewScanner(f)
    for input.Scan() {
        counts[input.Text()]++
    }
    // NOTE: ignoring potential errors from input.Err()
}

```

*`os.Open` å‡½æ•°è¿”å›ä¸¤ä¸ªå€¼ã€‚ç¬¬ä¸€ä¸ªå€¼æ˜¯è¢«æ‰“å¼€çš„æ–‡ä»¶ï¼ˆ`*os.File`ï¼‰ï¼Œå…¶åè¢« `Scanner` è¯»å–*ã€‚PS:ä½¿ç”¨é€è¡Œè¯»å–ï¼Œ**å†…å­˜å ç”¨æ›´ä½**ï¼ˆæ¯” `ReadFile` æ›´å®‰å…¨ï¼‰

*`os.Open` è¿”å›çš„ç¬¬äºŒä¸ªå€¼æ˜¯å†…ç½® `error` ç±»å‹çš„å€¼ã€‚å¦‚æœ `err` ç­‰äºå†…ç½®å€¼`nil`ï¼ˆè¯‘æ³¨ï¼šç›¸å½“äºå…¶å®ƒè¯­è¨€é‡Œçš„ `NULL`ï¼‰ï¼Œé‚£ä¹ˆæ–‡ä»¶è¢«æˆåŠŸæ‰“å¼€ã€‚*

*è¿›å…¥é”™è¯¯å¤„ç†æµç¨‹åï¼Œ`continue` è¯­å¥ç›´æ¥è·³åˆ° `for` å¾ªç¯çš„ä¸‹ä¸ªè¿­ä»£å¼€å§‹æ‰§è¡Œã€‚*

*å‡½æ•°å’ŒåŒ…çº§åˆ«çš„å˜é‡ï¼ˆpackage-level entitiesï¼‰å¯ä»¥ä»»æ„é¡ºåºå£°æ˜ï¼Œå¹¶ä¸å½±å“å…¶è¢«è°ƒç”¨ã€‚*

*`map` æ˜¯ä¸€ä¸ªç”± `make` å‡½æ•°åˆ›å»ºçš„æ•°æ®ç»“æ„çš„å¼•ç”¨ã€‚`map` ä½œä¸ºå‚æ•°ä¼ é€’ç»™æŸå‡½æ•°æ—¶ï¼Œè¯¥å‡½æ•°æ¥æ”¶è¿™ä¸ªå¼•ç”¨çš„ä¸€ä»½æ‹·è´ï¼ˆcopyï¼Œæˆ–è¯‘ä¸ºå‰¯æœ¬ï¼‰ï¼Œè¢«è°ƒç”¨å‡½æ•°å¯¹ `map` åº•å±‚æ•°æ®ç»“æ„çš„ä»»ä½•ä¿®æ”¹ï¼Œè°ƒç”¨è€…å‡½æ•°éƒ½å¯ä»¥é€šè¿‡æŒæœ‰çš„ `map` å¼•ç”¨çœ‹åˆ°ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œ`countLines` å‡½æ•°å‘ `counts` æ’å…¥çš„å€¼ï¼Œä¹Ÿä¼šè¢« `main` å‡½æ•°çœ‹åˆ°ã€‚ï¼ˆè¯‘æ³¨ï¼šç±»ä¼¼äº C++ é‡Œçš„å¼•ç”¨ä¼ é€’ï¼Œå®é™…ä¸ŠæŒ‡é’ˆæ˜¯å¦ä¸€ä¸ªæŒ‡é’ˆäº†ï¼Œä½†å†…éƒ¨å­˜çš„å€¼æŒ‡å‘åŒä¸€å—å†…å­˜ï¼‰*



å‰ä¸¤ä¸ªä¾‹å­åŸºäºâ€œæµâ€çš„æ¨¡å¼è¯»å–æ•°æ®ï¼Œä¸‹é¢å°†å…¨éƒ¨æ•°æ®ä¸€æ¬¡æ€§è¯»å…¥å†…å­˜

```go
package main

import (
    "fmt"
    "io/ioutil"
    "os"
    "strings"
)

func main() {
    counts := make(map[string]int)
    for _, filename := range os.Args[1:] {
        data, err := ioutil.ReadFile(filename)
        if err != nil {
            fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
            continue
        }
      //è½¬æ¢ä¸ºstringåæŒ‰æ¢è¡Œç¬¦åˆ†å‰²
        for _, line := range strings.Split(string(data), "\n") {
            counts[line]++
        }
    }
    for line, n := range counts {
        if n > 1 {
            fmt.Printf("%d\t%s\n", n, line)
        }
    }
}

```



*ç®€åŒ–ï¼Œåªè¯»æŒ‡å®šæ–‡ä»¶ï¼Œä¸è¯»æ ‡å‡†è¾“å…¥ã€‚å…¶æ¬¡ï¼Œç”±äºè¡Œè®¡æ•°ä»£ç åªåœ¨ä¸€å¤„ç”¨åˆ°ï¼Œæ•…å°†å…¶ç§»å› `main` å‡½æ•°ã€‚*

*`ReadFile` å‡½æ•°è¿”å›ä¸€ä¸ªå­—èŠ‚åˆ‡ç‰‡ï¼ˆbyte sliceï¼‰ï¼Œå¿…é¡»æŠŠå®ƒè½¬æ¢ä¸º `string`ï¼Œæ‰èƒ½ç”¨ `strings.Split` åˆ†å‰²ã€‚*

*å®ç°ä¸Šï¼Œ`bufio.Scanner`ã€`ioutil.ReadFile` å’Œ `ioutil.WriteFile` éƒ½ä½¿ç”¨ `*os.File` çš„ `Read` å’Œ `Write` æ–¹æ³•ï¼Œä½†æ˜¯ï¼Œå¤§å¤šæ•°ç¨‹åºå‘˜å¾ˆå°‘éœ€è¦ç›´æ¥è°ƒç”¨é‚£äº›ä½çº§ï¼ˆlower-levelï¼‰å‡½æ•°ã€‚é«˜çº§ï¼ˆhigher-levelï¼‰å‡½æ•°ï¼Œåƒ `bufio` å’Œ `io/ioutil` åŒ…ä¸­æ‰€æä¾›çš„é‚£äº›ï¼Œç”¨èµ·æ¥è¦å®¹æ˜“ç‚¹ã€‚*

**ç»ƒä¹  1.4ï¼š** ä¿®æ”¹ `dup2`ï¼Œå‡ºç°é‡å¤çš„è¡Œæ—¶æ‰“å°æ–‡ä»¶åç§°ã€‚

```go
// Dup2 prints the count and text of lines that appear more than once
// in the input.  It reads from stdin or from a list of named files.
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	// map[filename][line]count
	counts := make(map[string]map[string]int)
	files := os.Args[1:]
	if len(files) == 0 {
		countLines("<stdin>", os.Stdin, counts)
	} else {
		for _, filename := range files {
			f, err := os.Open(filename)
			if err != nil {
				fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
				continue
			}
			countLines(filename, f, counts)
			f.Close()
		}
	}
	for filename, lineMap := range counts {
		for line, n := range lineMap {
			if n > 1 {
				fmt.Printf("%s\t%d\t%s\n", filename, n, line)
			}
		}
	}
}

func countLines(filename string, f *os.File, counts map[string]map[string]int) {
	// å®‰å…¨åˆå§‹åŒ– map çš„æ ‡å‡†å†™æ³•ï¼Œç”¨äºå¤„ç†åµŒå¥— map çš„æƒ…å†µ
	if counts[filename] == nil {
		counts[filename] = make(map[string]int)
	}

	input := bufio.NewScanner(f)
	for input.Scan() {
		line := input.Text()
		counts[filename][line]++
	}
	// NOTE: ignoring potential errors from input.Err()
}
```

æ€è·¯ï¼š

é¦–å…ˆè¦ä¿®æ”¹countsçš„ç±»å‹ä¸ºmap[string]map[string]intï¼Œ

å…¶æ¬¡ä¿®æ”¹countLineså‡½æ•°ï¼Œä½¿å…¶æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼Œå¹¶åœ¨å‡½æ•°ä¸­å¢åŠ å®‰å…¨åˆå§‹åŒ–åµŒå¥—mapçš„æƒ…å†µï¼ˆ`counts` æ˜¯ä¸€ä¸ª mapï¼Œå®ƒçš„å€¼æœ¬èº«åˆæ˜¯ä¸€ä¸ª mapã€‚åœ¨ç¬¬ä¸€æ¬¡è®¿é—® `counts[filename]` æ—¶ï¼Œï¼ˆç¬¬äºŒå±‚ï¼‰é»˜è®¤æ˜¯ `nil`ï¼Œ**ä¸èƒ½ç›´æ¥èµ‹å€¼**ï¼ŒGo ä¼šæŠ¥è¿è¡Œæ—¶é”™è¯¯ï¼‰

ä¿®æ”¹forå¾ªç¯ï¼Œå¤„ç†åµŒå¥—mapçš„æƒ…å†µ

#### 1.4. GIFåŠ¨ç”»

```go
// Lissajous generates GIF animations of random Lissajous figures.
package main

import (
    "image"
    "image/color"
    "image/gif"
    "io"
    "math"
    "math/rand"
    "os"
    "time"
)
/*
color.Color æ˜¯ Go æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªæ¥å£ï¼Œç”¨äºè¡¨ç¤ºâ€œä¸€ä¸ªé¢œè‰²â€ã€‚
éƒ¨åˆ†	å«ä¹‰
var palette	å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œåå­—å« palette
[]color.Color	ç±»å‹æ˜¯ï¼šcolor.Color æ¥å£çš„åˆ‡ç‰‡ï¼ˆå³å¯ä»¥å­˜å¤šä¸ªé¢œè‰²ï¼‰
{color.White, color.Black}	åˆ‡ç‰‡çš„åˆå§‹å€¼æ˜¯ç™½è‰²å’Œé»‘è‰²ä¸¤ä¸ªé¢œè‰²
*/
var palette = []color.Color{color.White, color.Black}

const (
    whiteIndex = 0 // first color in palette
    blackIndex = 1 // next color in palette
)

func main() {
    // The sequence of images is deterministic unless we seed
    // the pseudo-random number generator using the current time.
    // Thanks to Randall McPherson for pointing out the omission.
    rand.Seed(time.Now().UTC().UnixNano())
    lissajous(os.Stdout)
}

func lissajous(out io.Writer) {
    const (
        cycles  = 5     // number of complete x oscillator revolutions
        res     = 0.001 // angular resolution
        size    = 100   // image canvas covers [-size..+size]
        nframes = 64    // number of animation frames
        delay   = 8     // delay between frames in 10ms units
    )

    freq := rand.Float64() * 3.0 // relative frequency of y oscillator
    anim := gif.GIF{LoopCount: nframes}
    phase := 0.0 // phase difference
    for i := 0; i < nframes; i++ {
        rect := image.Rect(0, 0, 2*size+1, 2*size+1)
        img := image.NewPaletted(rect, palette)
        for t := 0.0; t < cycles*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5),
                blackIndex)
        }
        phase += 0.1
        anim.Delay = append(anim.Delay, delay)
        anim.Image = append(anim.Image, img)
    }
    gif.EncodeAll(out, &anim) // NOTE: ignoring encoding errors
}


```

åœ¨åŒ…çš„å¯¼å…¥è·¯å¾„åŒ…å«å¤šä¸ªå•è¯æ—¶ï¼Œå¦‚â€œimage/colorâ€ï¼Œå¯ä»¥åªç”¨æœ€åä¸€ä¸ªå•è¯è¡¨ç¤º->color.White

åœ¨ Go è¯­è¨€ä¸­ï¼Œ`const` ç”¨äºå£°æ˜**å¸¸é‡**ï¼ˆconstantï¼‰ï¼Œå³åœ¨ç¼–è¯‘æ—¶å°±ç¡®å®šäº†å€¼ï¼Œä¸”è¿è¡Œæ—¶ä¸å¯æ›´æ”¹ã€‚





**ç»ƒä¹  1.5ï¼š** ä¿®æ”¹å‰é¢çš„Lissajousç¨‹åºé‡Œçš„è°ƒè‰²æ¿ï¼Œç”±é»‘è‰²æ”¹ä¸ºç»¿è‰²ã€‚æˆ‘ä»¬å¯ä»¥ç”¨`color.RGBA{0xRR, 0xGG, 0xBB, 0xff}`æ¥å¾—åˆ°`#RRGGBB`è¿™ä¸ªè‰²å€¼ï¼Œä¸‰ä¸ªåå…­è¿›åˆ¶çš„å­—ç¬¦ä¸²åˆ†åˆ«ä»£è¡¨çº¢ã€ç»¿ã€è“åƒç´ ã€‚

```
var palette = []color.Color{color.White, color.RGBA{0x00, 0xff, 0x00, 0xff}} // ç»¿è‰²
```

**ç»ƒä¹  1.6ï¼š** ä¿®æ”¹Lissajousç¨‹åºï¼Œä¿®æ”¹å…¶è°ƒè‰²æ¿æ¥ç”Ÿæˆæ›´ä¸°å¯Œçš„é¢œè‰²ï¼Œç„¶åä¿®æ”¹SetColorIndexçš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œçœ‹çœ‹æ˜¾ç¤ºç»“æœå§ã€‚

```go
var palette = []color.Color{
    color.White,                   // index 0ï¼šèƒŒæ™¯è‰²
    color.RGBA{255, 0, 0, 255},    // index 1ï¼šçº¢
    color.RGBA{255, 165, 0, 255},  // index 2ï¼šæ©™
    color.RGBA{255, 255, 0, 255},  // index 3ï¼šé»„
    color.RGBA{0, 255, 0, 255},    // index 4ï¼šç»¿
    color.RGBA{0, 0, 255, 255},    // index 5ï¼šè“
}
.........
.........
const (
	whiteIndex = 0 // first color in palette
)
........
........
colorIndex := uint8(i%(len(palette)-1) + 1)

		for t := 0.0; t < cycles*2*math.Pi; t += res {
			x := math.Sin(t)
			y := math.Sin(t*freq + phase)
			img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), colorIndex)
		}


```

é¦–å…ˆå®šä¹‰äº†è°ƒè‰²æ¿åŒ…å«ä¸€ä¸ªèƒŒæ™¯è‰²å’Œäº”ä¸ªé¢œè‰²ï¼Œè¿™æ—¶ `len(palette) = 6`ï¼Œå…¶ä¸­ï¼š

- `palette[0]` æ˜¯èƒŒæ™¯ç™½è‰²
- `palette[1]`~`palette[5]` æ˜¯å½©è‰²çº¿æ¡é¢œè‰²



colorIndex := uint8(i%(len(palette)-1) + 1)ç”¨äºéšæœºï¼š

`len(palette) - 1 = 5`ï¼šå»æ‰èƒŒæ™¯è‰²ï¼Œåªç”¨å½©è‰²éƒ¨åˆ†

`i % 5`ï¼šç¡®ä¿å¸§ç¼–å·åœ¨ 0~4 ä¹‹é—´å¾ªç¯ï¼ˆé¿å…è¶…å‡ºç´¢å¼•ï¼‰

`+1`ï¼šè·³è¿‡èƒŒæ™¯è‰² `palette[0]`ï¼Œç¡®ä¿é¢œè‰²ç´¢å¼•ä» 1 å¼€å§‹

uint8ï¼šSetColorIndexéœ€è¦çš„ç±»å‹

#### 1.5.è·å–url

*ä¸ºäº†æœ€ç®€å•åœ°å±•ç¤ºåŸºäºHTTPè·å–ä¿¡æ¯çš„æ–¹å¼ï¼Œä¸‹é¢ç»™å‡ºä¸€ä¸ªç¤ºä¾‹ç¨‹åºfetchï¼Œè¿™ä¸ªç¨‹åºå°†è·å–å¯¹åº”çš„urlï¼Œå¹¶å°†å…¶æºæ–‡æœ¬æ‰“å°å‡ºæ¥ï¼›è¿™ä¸ªä¾‹å­çš„çµæ„Ÿæ¥æºäºcurlå·¥å…·ã€‚å½“ç„¶ï¼Œcurlæä¾›çš„åŠŸèƒ½æ›´ä¸ºå¤æ‚ä¸°å¯Œï¼Œè¿™é‡Œåªç¼–å†™æœ€ç®€å•çš„æ ·ä¾‹ã€‚è¿™ä¸ªæ ·ä¾‹ä¹‹åè¿˜ä¼šå¤šæ¬¡è¢«ç”¨åˆ°ã€‚*

```go
// Fetch prints the content found at a URL.
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
    "os"
)

func main() {
    for _, url := range os.Args[1:] {
        resp, err := http.Get(url)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
            os.Exit(1)
        }
        b, err := io.ReadAll(resp.Body)
        resp.Body.Close()
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
            os.Exit(1)
        }
        fmt.Printf("%s", b)
    }
}

```



**ç»ƒä¹  1.7ï¼š** å‡½æ•°è°ƒç”¨io.Copy(dst, src)ä¼šä»srcä¸­è¯»å–å†…å®¹ï¼Œå¹¶å°†è¯»åˆ°çš„ç»“æœå†™å…¥åˆ°dstä¸­ï¼Œä½¿ç”¨è¿™ä¸ªå‡½æ•°æ›¿ä»£æ‰ä¾‹å­ä¸­çš„ioutil.ReadAllæ¥æ‹·è´å“åº”ç»“æ„ä½“åˆ°os.Stdoutï¼Œé¿å…ç”³è¯·ä¸€ä¸ªç¼“å†²åŒºï¼ˆä¾‹å­ä¸­çš„bï¼‰æ¥å­˜å‚¨ã€‚è®°å¾—å¤„ç†io.Copyè¿”å›ç»“æœä¸­çš„é”™è¯¯ã€‚

```go
// Fetch prints the content found at a URL.
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
)

func main() {
    for _, url := range os.Args[1:] {
        resp, err := http.Get(url)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
            os.Exit(1)
        }
      
       defer resp.Body.Close()
      
        _, err = io.Copy(os.Stdout, resp.Body)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: Copy faild %s: %v\n", url, err)
            os.Exit(1)
        }
    }
}

```

`defer resp.Body.Close()`ï¼š`defer` æ˜¯ Go çš„å»¶è¿Ÿæ‰§è¡Œæœºåˆ¶ï¼Œåœ¨å‡½æ•°ç»“æŸæ—¶è‡ªåŠ¨æ‰§è¡Œã€‚

`resp.Body` æ˜¯ä¸€ä¸ª `io.ReadCloser`ï¼Œå®ƒæ˜¯è¿æ¥æœåŠ¡å™¨çš„æ•°æ®æµé€šé“ã€‚ä½ **å¿…é¡»æ‰‹åŠ¨å…³é—­å®ƒ**ï¼Œå¦åˆ™è¿æ¥ä¼šä¸€ç›´å ç”¨å†…å­˜å’Œèµ„æºã€‚

`io.Copy`æœ‰ä¸¤ä¸ªè¿”å›å€¼ï¼šè¿”å›çš„å­—èŠ‚æ•°ã€errï¼Œæˆ‘ä»¬åªå…³æ³¨è¿”å›çš„é”™è¯¯ï¼Œä½¿ç”¨_å¿½ç•¥ç¬¬ä¸€ä¸ªè¿”å›å€¼ã€‚

**ç»ƒä¹  1.8ï¼š** ä¿®æ”¹fetchè¿™ä¸ªèŒƒä¾‹ï¼Œå¦‚æœè¾“å…¥çš„urlå‚æ•°æ²¡æœ‰ `http://` å‰ç¼€çš„è¯ï¼Œä¸ºè¿™ä¸ªurlåŠ ä¸Šè¯¥å‰ç¼€ã€‚ä½ å¯èƒ½ä¼šç”¨åˆ°strings.HasPrefixè¿™ä¸ªå‡½æ•°ã€‚

```
 if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
            url = "http://" + url
        }
```

`func HasPrefix(s, prefix string) bool` åˆ¤æ–­sæ˜¯å¦ä»¥prefixå¼€å¤´

**ç»ƒä¹  1.9ï¼š** ä¿®æ”¹fetchæ‰“å°å‡ºHTTPåè®®çš„çŠ¶æ€ç ï¼Œå¯ä»¥ä»resp.Statuså˜é‡å¾—åˆ°è¯¥çŠ¶æ€ç ã€‚

```
        //æ‰“å°çŠ¶æ€ç ï¼Œä¸éœ€è¦åœ¨å¼‚å¸¸æµç¨‹é‡Œæ‰“å°ï¼Œå› ä¸ºerræ—¶resp == nil
        fmt.Fprintf(os.Stdout, "status code: %s\n\n", resp.Status)
```

å®Œæ•´ä»£ç 

```
// Fetch prints the content found at a URL.
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
    "strings"
)

func main() {
    for _, url := range os.Args[1:] {
    	if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
    		url = "http://" + url
    	}
        resp, err := http.Get(url)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
            os.Exit(1)
        }
      
        defer resp.Body.Close()
        //æ‰“å°çŠ¶æ€ç ï¼Œä¸éœ€è¦åœ¨å¼‚å¸¸æµç¨‹é‡Œæ‰“å°ï¼Œå› ä¸ºerræ—¶resp == nil
        fmt.Fprintf(os.Stdout, "status code: %s\n\n", resp.Status)

        _, err = io.Copy(os.Stdout, resp.Body)
        if err != nil {
            fmt.Fprintf(os.Stderr, "fetch: Copy faild %s: %v\n", url, err)
            os.Exit(1)
        }
        
    }
}

```

#### 1.6.å¹¶å‘è·å–å¤šä¸ªurl

*Goè¯­è¨€æœ€æœ‰æ„æ€å¹¶ä¸”æœ€æ–°å¥‡çš„ç‰¹æ€§å°±æ˜¯å¯¹å¹¶å‘ç¼–ç¨‹çš„æ”¯æŒã€‚å¹¶å‘ç¼–ç¨‹æ˜¯ä¸€ä¸ªå¤§è¯é¢˜ï¼Œåœ¨ç¬¬å…«ç« å’Œç¬¬ä¹ç« ä¸­ä¼šä¸“é—¨è®²åˆ°ã€‚è¿™é‡Œæˆ‘ä»¬åªæµ…å°è¾„æ­¢åœ°æ¥ä½“éªŒä¸€ä¸‹Goè¯­è¨€é‡Œçš„goroutineå’Œchannelã€‚*

```go
// Fetchall fetches URLs in parallel and reports their times and sizes.
package main

import (
    "fmt"
    "io"
    "io/ioutil"
    "net/http"
    "os"
    "time"
)

func main() {
    start := time.Now()
    ch := make(chan string)
    for _, url := range os.Args[1:] {
        go fetch(url, ch) // start a goroutine
    }
    for range os.Args[1:] {
        fmt.Println(<-ch) // receive from channel ch
    }
    fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}

func fetch(url string, ch chan<- string) {
    start := time.Now()
    resp, err := http.Get(url)
    if err != nil {
        ch <- fmt.Sprint(err) // send to channel ch
        return
    }
    nbytes, err := io.Copy(ioutil.Discard, resp.Body)
    resp.Body.Close() // don't leak resources
    if err != nil {
        ch <- fmt.Sprintf("while reading %s: %v", url, err)
        return
    }
    secs := time.Since(start).Seconds()
    ch <- fmt.Sprintf("%.2fs  %7d  %s", secs, nbytes, url)
}

```

`go fetch(url, ch) // start a goroutine`

å¯åŠ¨ä¸€ä¸ªæ–°çš„goroutineæ‰§è¡Œfetch(url, ch)å‡½æ•°ï¼Œæ¯ä¸ªURLéƒ½åœ¨ç‹¬ç«‹çš„çº¿ç¨‹ä¸­è¯·æ±‚ï¼Œmainçº¿ç¨‹ä¸ä¼šé˜»å¡ï¼Œä¼šç»§ç»­æ‰§è¡Œã€‚

*goroutineæ˜¯ä¸€ç§å‡½æ•°çš„å¹¶å‘æ‰§è¡Œæ–¹å¼ï¼Œè€Œchannelæ˜¯ç”¨æ¥åœ¨goroutineä¹‹é—´è¿›è¡Œå‚æ•°ä¼ é€’ã€‚mainå‡½æ•°æœ¬èº«ä¹Ÿè¿è¡Œåœ¨ä¸€ä¸ªgoroutineä¸­*

` ch := make(chan string)`

åˆ›å»ºä¸€ä¸ªchannelï¼ˆé€šé“ï¼‰ï¼Œè®©goroutineæŠŠç»“æœä¼ å›ä¸»goroutine

`ch <- fmt.Sprintf("%.2fs  %7d  %s", secs, nbytes, url)`

fetchå‡½æ•°æŠŠæ ¼å¼åŒ–å¥½çš„å­—ç¬¦ä¸²å‘é€åˆ°é€šé“chï¼Œè¿™ä¸ªè¿‡ç¨‹ä¼š**é˜»å¡å‘é€æ–¹**ï¼Œç›´åˆ°æœ‰æ¥æ”¶æ–¹ï¼ˆmain å‡½æ•°ï¼‰ä» `ch` ä¸­è¯»å–ã€‚

    for range os.Args[1:] {
        fmt.Println(<-ch) // receive from channel ch
    }

ä¸»çº¿ç¨‹ä¾æ¬¡æ¥æ”¶å¹¶æ‰“å°

æ€»ä½“æµç¨‹

```
main()
â”‚
â”œâ”€â”€ åˆ›å»º channel ch
â”‚
â”œâ”€â”€ å¯åŠ¨ N ä¸ª goroutine å¹¶å‘ fetch(url, ch)
â”‚      â””â”€â”€ æ¯ä¸ª fetch æ‰§è¡Œ http.Get
â”‚      â””â”€â”€ å®Œæˆåé€šè¿‡ ch <- result æŠŠç»“æœå‘å›ä¸»çº¿ç¨‹
â”‚
â”œâ”€â”€ ä¸»çº¿ç¨‹é€šè¿‡ <-ch è¯»å–æ¯ä¸ªç»“æœï¼ˆå…± N æ¬¡ï¼‰
â”‚
â””â”€â”€ æ‰“å°æ€»è€—æ—¶

```

**ç»ƒä¹  1.10ï¼š** æ‰¾ä¸€ä¸ªæ•°æ®é‡æ¯”è¾ƒå¤§çš„ç½‘ç«™ï¼Œç”¨æœ¬å°èŠ‚ä¸­çš„ç¨‹åºè°ƒç ”ç½‘ç«™çš„ç¼“å­˜ç­–ç•¥ï¼Œå¯¹æ¯ä¸ªURLæ‰§è¡Œä¸¤éè¯·æ±‚ï¼ŒæŸ¥çœ‹ä¸¤æ¬¡æ—¶é—´æ˜¯å¦æœ‰è¾ƒå¤§çš„å·®åˆ«ï¼Œå¹¶ä¸”æ¯æ¬¡è·å–åˆ°çš„å“åº”å†…å®¹æ˜¯å¦ä¸€è‡´ï¼Œä¿®æ”¹æœ¬èŠ‚ä¸­çš„ç¨‹åºï¼Œå°†å“åº”ç»“æœè¾“å‡ºåˆ°æ–‡ä»¶ï¼Œä»¥ä¾¿äºè¿›è¡Œå¯¹æ¯”ã€‚

```go
// Fetchall fetches URLs in parallel and reports their times and sizes.
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
    "time"
    "strings"
)

func main() {
    start := time.Now()
    ch := make(chan string)

    for _, url := range os.Args[1:] {
        go fetch(url, ch) // start a goroutine
    }
    for range os.Args[1:] {
        fmt.Println(<-ch) // receive from channel ch
    }

    fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}

func fetch(url string, ch chan<-- string) {
    start := time.Now()
    resp, err := http.Get(url)
    if err != nil {
        ch <- fmt.Sprint(err) // send to channel ch
        return
    }
    filename := sanitizeFilename(url) + ".html"
    file, err := os.Create(filename)
    if err != nil {
        ch <- fmt.Sprintf("create file error for %s: %v", url, err)
        return
    }
    defer file.Close()

    // å°† body å†…å®¹å†™å…¥æ–‡ä»¶ï¼ŒåŒæ—¶ç»Ÿè®¡å¤§å°
    nbytes, err := io.Copy(file, resp.Body)
    if err != nil {
        ch <- fmt.Sprintf("write error for %s: %v", url, err)
        return
    }

    secs := time.Since(start).Seconds()
    ch <- fmt.Sprintf("%.2fs  %7d  %s  -> saved to %s", secs, nbytes, url, filename)
}

// sanitizeFilename å°† URL ç®€åŒ–ä¸ºåˆæ³•æ–‡ä»¶å
func sanitizeFilename(url string) string {
    url = strings.TrimPrefix(url, "http://")
    url = strings.TrimPrefix(url, "https://")
    url = strings.ReplaceAll(url, "/", "_")
    return url
}

```

ä¸»è¦ä¿®æ”¹fetchå‡½æ•°ï¼Œå°†Bodyå†…å®¹å†™å…¥æ–‡ä»¶

```go
â¯ go run ./fetchall.go https://golang-china.github.io/gopl-zh/
0.39s    30164  https://golang-china.github.io/gopl-zh/  -> saved to golang-china.github.io_gopl-zh_.html
0.39s elapsed
â¯ mv golang-china.github.io_gopl-zh_.html a.html
â¯ go run ./fetchall.go https://golang-china.github.io/gopl-zh/
0.22s    30164  https://golang-china.github.io/gopl-zh/  -> saved to golang-china.github.io_gopl-zh_.html
0.22s elapsed
â¯ diff a.html golang-china.github.io_gopl-zh_.html
```

**ç»ƒä¹  1.11ï¼š** åœ¨fetchallä¸­å°è¯•ä½¿ç”¨é•¿ä¸€äº›çš„å‚æ•°åˆ—è¡¨ï¼Œæ¯”å¦‚ä½¿ç”¨åœ¨alexa.comçš„ä¸Šç™¾ä¸‡ç½‘ç«™é‡Œæ’åé å‰çš„ã€‚å¦‚æœä¸€ä¸ªç½‘ç«™æ²¡æœ‰å›åº”ï¼Œç¨‹åºå°†é‡‡å–æ€æ ·çš„è¡Œä¸ºï¼Ÿï¼ˆSection8.9 æè¿°äº†åœ¨è¿™ç§æƒ…å†µä¸‹çš„åº”å¯¹æœºåˆ¶ï¼‰ã€‚

```go
 client := http.Client{
        Timeout: 5 * time.Second,
    }

    resp, err := client.Get(url)
```

åˆ›å»ºä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œè®¾ç½®è¶…æ—¶æ—¶é—´ã€

é™åˆ¶å¹¶å‘æ•°é‡ã€è®°å½•æ—¥å¿—ï¼ˆåç»­å†å°è¯•ï¼‰

---

Qï¼šæœ¬å°ç»“ç”¨åˆ°çš„å‡ ä¸ªprintæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

Aï¼š

| å‡½æ•°      | ç”¨é€”                      | æ˜¯å¦æ ¼å¼åŒ– | æ˜¯å¦æ¢è¡Œ | æ˜¯å¦è¿”å›å­—ç¬¦ä¸² |
| --------- | ------------------------- | ---------- | -------- | -------------- |
| `Sprintf` | æ„é€ å­—ç¬¦ä¸²ï¼Œä¸æ‰“å°        | âœ…          | âŒ        | âœ…              |
| `Printf`  | æ ¼å¼åŒ–å¹¶æ‰“å°              | âœ…          | âŒ        | âŒ              |
| `Println` | ç›´æ¥æ‰“å°ï¼ˆè‡ªåŠ¨ç©ºæ ¼+æ¢è¡Œï¼‰ | âŒ          | âœ…        | âŒ              |

---

#### 1.7.webæœåŠ¡

**ç»ƒä¹  1.12ï¼š** ä¿®æ”¹LissajouræœåŠ¡ï¼Œä»URLè¯»å–å˜é‡ï¼Œæ¯”å¦‚ä½ å¯ä»¥è®¿é—® http://localhost:8000/?cycles=20 è¿™ä¸ªURLï¼Œè¿™æ ·è®¿é—®å¯ä»¥å°†ç¨‹åºé‡Œçš„cyclesé»˜è®¤çš„5ä¿®æ”¹ä¸º20ã€‚å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å­—å¯ä»¥è°ƒç”¨strconv.Atoiå‡½æ•°ã€‚ä½ å¯ä»¥åœ¨godocé‡ŒæŸ¥çœ‹strconv.Atoiçš„è¯¦ç»†è¯´æ˜ã€‚

```go
// Server1 is a minimal "echo" server.
package main

import (
    "image"
    "image/color"
    "image/gif"
    "io"
    "math"
    "math/rand"
	  "net/http"
    "log"
    "fmt"
    "strconv"
)


var palette = []color.Color{
    color.White,                        // èƒŒæ™¯è‰²
    color.RGBA{0xFF, 0x00, 0x00, 0xFF}, // çº¢
    color.RGBA{0xFF, 0xA5, 0x00, 0xFF}, // æ©™
    color.RGBA{0xFF, 0xFF, 0x00, 0xFF}, // é»„
    color.RGBA{0x00, 0xFF, 0x00, 0xFF}, // ç»¿
    color.RGBA{0x00, 0x00, 0xFF, 0xFF}, // è“
    color.RGBA{0x4B, 0x00, 0x82, 0xFF}, // é›
    color.RGBA{0x8B, 0x00, 0xFF, 0xFF}, // ç´«
}

const (
    whiteIndex = 0 // first color in palette
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
    r.ParseForm() // è§£æURLä¸­çš„å‚æ•°
    cycles := 5
    //è·å–cycelå€¼
    if val := r.Form.Get("cycles"); val != "" {
    //å­—ç¬¦ä¸²è½¬æ¢in t
            if parsed, err := strconv.Atoi(val); err == nil {
                cycles = parsed
            }
        }

    lissajous(w, cycles)
})
    log.Fatal(http.ListenAndServe("localhost:8000", nil))
}

//ä¿®æ”¹å‡½æ•°ç­¾å
func lissajous(out io.Writer, cycles int) {
    const (
        res     = 0.001 // angular resolution
        size    = 100   // image canvas covers [-size..+size]
        nframes = 64    // number of animation frames
        delay   = 8     // delay between frames in 10ms units
    )

    freq := rand.Float64() * 3.0 // relative frequency of y oscillator
    anim := gif.GIF{LoopCount: nframes}
    phase := 0.0 // phase difference
    for i := 0; i < nframes; i++ {
        rect := image.Rect(0, 0, 2*size+1, 2*size+1)
        img := image.NewPaletted(rect, palette)

        colorIndex := uint8(i%(len(palette)-1) + 1)
				//è¿›è¡Œæµ®ç‚¹æ•°è®¡ç®—ï¼Œè½¬æ¢cyclesç±»å‹
        for t := 0.0; t < float64(cycles)*2*math.Pi; t += res {
            x := math.Sin(t)
            y := math.Sin(t*freq + phase)
            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), colorIndex)
        }
        phase += 0.1
        anim.Delay = append(anim.Delay, delay)
        anim.Image = append(anim.Image, img)
    }
    gif.EncodeAll(out, &anim) // NOTE: ignoring encoding errors
}

```

#### 1.8.æœ¬ç« è¦ç‚¹

*æœ¬ç« å¯¹Goè¯­è¨€åšäº†ä¸€äº›ä»‹ç»ï¼ŒGoè¯­è¨€å¾ˆå¤šæ–¹é¢åœ¨æœ‰é™çš„ç¯‡å¹…ä¸­æ— æ³•è¦†ç›–åˆ°ã€‚æœ¬èŠ‚ä¼šæŠŠæ²¡æœ‰è®²åˆ°çš„å†…å®¹ä¹Ÿåšä¸€äº›ç®€å•çš„ä»‹ç»ï¼Œè¿™æ ·è¯»è€…åœ¨è¯»åˆ°å®Œæ•´çš„å†…å®¹ä¹‹å‰ï¼Œå¯ä»¥æœ‰ä¸ªç®€å•çš„å°è±¡ã€‚*

***æ§åˆ¶æµï¼š** åœ¨æœ¬ç« æˆ‘ä»¬åªä»‹ç»äº†ifæ§åˆ¶å’Œforï¼Œä½†æ˜¯æ²¡æœ‰æåˆ°switchå¤šè·¯é€‰æ‹©ã€‚è¿™é‡Œæ˜¯ä¸€ä¸ªç®€å•çš„switchçš„ä¾‹å­ï¼š*

```
switch coinflip() {
case "heads":
    heads++
case "tails":
    tails++
default:
    fmt.Println("landed on edge!")
}
```

*åœ¨æ¯ä¸€ä¸ªå‡½æ•°ä¹‹å‰å†™ä¸€ä¸ªè¯´æ˜å‡½æ•°è¡Œä¸ºçš„æ³¨é‡Šä¹Ÿæ˜¯ä¸€ä¸ªå¥½ä¹ æƒ¯ã€‚è¿™äº›æƒ¯ä¾‹å¾ˆé‡è¦ï¼Œå› ä¸ºè¿™äº›å†…å®¹ä¼šè¢«åƒgodocè¿™æ ·çš„å·¥å…·æ£€æµ‹åˆ°ï¼Œå¹¶ä¸”åœ¨æ‰§è¡Œå‘½ä»¤æ—¶æ˜¾ç¤ºè¿™äº›æ³¨é‡Š*

*å¤šè¡Œæ³¨é‡Šå¯ä»¥ç”¨ `/* ... */` æ¥åŒ…è£¹ï¼Œå’Œå…¶å®ƒå¤§å¤šæ•°è¯­è¨€ä¸€æ ·ã€‚*

### 2.ç¨‹åºç»“æ„

*Goè¯­è¨€å’Œå…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸€æ ·ï¼Œä¸€ä¸ªå¤§çš„ç¨‹åºæ˜¯ç”±å¾ˆå¤šå°çš„åŸºç¡€æ„ä»¶ç»„æˆçš„ã€‚å˜é‡ä¿å­˜å€¼ï¼Œç®€å•çš„åŠ æ³•å’Œå‡æ³•è¿ç®—è¢«ç»„åˆæˆè¾ƒå¤æ‚çš„è¡¨è¾¾å¼ã€‚åŸºç¡€ç±»å‹è¢«èšåˆä¸ºæ•°ç»„æˆ–ç»“æ„ä½“ç­‰æ›´å¤æ‚çš„æ•°æ®ç»“æ„ã€‚ç„¶åä½¿ç”¨ifå’Œforä¹‹ç±»çš„æ§åˆ¶è¯­å¥æ¥ç»„ç»‡å’Œæ§åˆ¶è¡¨è¾¾å¼çš„æ‰§è¡Œæµç¨‹ã€‚ç„¶åå¤šä¸ªè¯­å¥è¢«ç»„ç»‡åˆ°ä¸€ä¸ªä¸ªå‡½æ•°ä¸­ï¼Œä»¥ä¾¿ä»£ç çš„éš”ç¦»å’Œå¤ç”¨ã€‚å‡½æ•°ä»¥æºæ–‡ä»¶å’ŒåŒ…çš„æ–¹å¼è¢«ç»„ç»‡ã€‚*

*æˆ‘ä»¬å·²ç»åœ¨å‰é¢ç« èŠ‚çš„ä¾‹å­ä¸­çœ‹åˆ°äº†å¾ˆå¤šä¾‹å­ã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥è®¨è®ºGoç¨‹åºåŸºç¡€ç»“æ„æ–¹é¢çš„ä¸€äº›ç»†èŠ‚ã€‚æ¯ä¸ªç¤ºä¾‹ç¨‹åºéƒ½æ˜¯åˆ»æ„å†™çš„ç®€å•ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥å‡å°‘å¤æ‚çš„ç®—æ³•æˆ–æ•°æ®ç»“æ„ç­‰ä¸ç›¸å…³çš„é—®é¢˜å¸¦æ¥çš„å¹²æ‰°ï¼Œä»è€Œå¯ä»¥ä¸“æ³¨äºGoè¯­è¨€æœ¬èº«çš„å­¦ä¹ ã€‚*

#### 2.1.å‘½å

*Goè¯­è¨€ä¸­çš„å‡½æ•°åã€å˜é‡åã€å¸¸é‡åã€ç±»å‹åã€è¯­å¥æ ‡å·å’ŒåŒ…åç­‰æ‰€æœ‰çš„å‘½åï¼Œéƒ½éµå¾ªä¸€ä¸ªç®€å•çš„å‘½åè§„åˆ™ï¼šä¸€ä¸ªåå­—å¿…é¡»ä»¥ä¸€ä¸ªå­—æ¯ï¼ˆUnicodeå­—æ¯ï¼‰æˆ–ä¸‹åˆ’çº¿å¼€å¤´ï¼Œåé¢å¯ä»¥è·Ÿä»»æ„æ•°é‡çš„å­—æ¯ã€æ•°å­—æˆ–ä¸‹åˆ’çº¿ã€‚å¤§å†™å­—æ¯å’Œå°å†™å­—æ¯æ˜¯ä¸åŒçš„ï¼šheapSortå’ŒHeapsortæ˜¯ä¸¤ä¸ªä¸åŒçš„åå­—ã€‚*

ç±»ä¼¼ifå’Œswitchçš„å…³é”®å­—æœ‰25ä¸ªï¼›å…³é”®å­—ä¸èƒ½ç”¨äºè‡ªå®šä¹‰åå­—ï¼Œåªèƒ½åœ¨ç‰¹å®šè¯­æ³•ç»“æ„ä¸­ä½¿ç”¨ã€‚

```
break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
```

æ­¤å¤–ï¼Œè¿˜æœ‰å¤§çº¦30å¤šä¸ªé¢„å®šä¹‰çš„åå­—ï¼Œæ¯”å¦‚intå’Œtrueç­‰ï¼Œä¸»è¦å¯¹åº”å†…å»ºçš„å¸¸é‡ã€ç±»å‹å’Œå‡½æ•°ã€‚

```
å†…å»ºå¸¸é‡: true false iota nil

å†…å»ºç±»å‹: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

å†…å»ºå‡½æ•°: make len cap new append copy close delete
          complex real imag
          panic recover
```

*è¿™äº›å†…éƒ¨é¢„å…ˆå®šä¹‰çš„åå­—å¹¶ä¸æ˜¯å…³é”®å­—ï¼Œä½ å¯ä»¥åœ¨å®šä¹‰ä¸­é‡æ–°ä½¿ç”¨å®ƒä»¬ã€‚*



*å¦‚æœä¸€ä¸ªåå­—æ˜¯åœ¨å‡½æ•°**å†…éƒ¨å®šä¹‰**ï¼Œé‚£ä¹ˆå®ƒå°±åªåœ¨å‡½æ•°å†…éƒ¨æœ‰æ•ˆã€‚å¦‚æœæ˜¯åœ¨å‡½æ•°**å¤–éƒ¨å®šä¹‰**ï¼Œé‚£ä¹ˆå°†åœ¨å½“å‰åŒ…çš„æ‰€æœ‰æ–‡ä»¶ä¸­éƒ½å¯ä»¥è®¿é—®ã€‚åå­—çš„**å¼€å¤´å­—æ¯çš„å¤§å°å†™å†³å®šäº†åå­—åœ¨åŒ…å¤–çš„å¯è§æ€§**ã€‚**ä¾‹å¦‚fmtåŒ…çš„Printfå‡½æ•°å°±æ˜¯å¯¼å‡ºçš„ï¼Œå¯ä»¥åœ¨fmtåŒ…å¤–éƒ¨è®¿é—®ã€‚åŒ…æœ¬èº«çš„åå­—ä¸€èˆ¬æ€»æ˜¯ç”¨å°å†™å­—æ¯*ã€‚

å¯¼å‡ºä¸¾ä¾‹ï¼š

```go
// åœ¨ mypkg åŒ…ä¸­å®šä¹‰çš„å†…å®¹
package mypkg

// å¯¼å‡ºç±»å‹ï¼ˆå¤–éƒ¨å¯è§ï¼‰
type Person struct {
    Name string // å¯¼å‡ºå­—æ®µ
    age  int    // æœªå¯¼å‡ºå­—æ®µï¼ˆåªèƒ½åœ¨ mypkg å†…è®¿é—®ï¼‰
}

// å¯¼å‡ºå‡½æ•°
func SayHello() {
    // ...
}

// æœªå¯¼å‡ºå‡½æ•°ï¼ˆå°å†™å­—æ¯å¼€å¤´ï¼Œåªèƒ½åœ¨ mypkg åŒ…å†…éƒ¨ä½¿ç”¨ï¼‰
func secretFunction() {
    // ...
}

```

```go
import "mypkg"

func main() {
    p := mypkg.Person{}  // âœ… å¯ä»¥è®¿é—®å¯¼å‡ºçš„ç±»å‹
    p.Name = "Alice"     // âœ… å¯ä»¥è®¿é—®å¯¼å‡ºçš„å­—æ®µ
    // p.age = 30         // âŒ ç¼–è¯‘é”™è¯¯ï¼Œage æ˜¯æœªå¯¼å‡ºçš„å­—æ®µ
    mypkg.SayHello()     // âœ… å¯¼å‡ºçš„å‡½æ•°
    // mypkg.secretFunction() // âŒ ç¼–è¯‘é”™è¯¯ï¼Œæœªå¯¼å‡ºçš„å‡½æ•°
}

```



*å°½é‡ä½¿ç”¨çŸ­å°çš„åå­—ï¼Œå¯¹äºå±€éƒ¨å˜é‡å°¤å…¶æ˜¯è¿™æ ·*

*å¦‚æœä¸€ä¸ªåå­—çš„ä½œç”¨åŸŸæ¯”è¾ƒå¤§ï¼Œç”Ÿå‘½å‘¨æœŸä¹Ÿæ¯”è¾ƒé•¿ï¼Œé‚£ä¹ˆç”¨é•¿çš„åå­—å°†ä¼šæ›´æœ‰æ„ä¹‰ã€‚*

*æ¨èä½¿ç”¨ **é©¼å³°å¼** å‘½åï¼Œè€ŒåƒASCIIå’ŒHTMLè¿™æ ·çš„ç¼©ç•¥è¯åˆ™é¿å…ä½¿ç”¨å¤§å°å†™æ··åˆçš„å†™æ³•ï¼Œå®ƒä»¬å¯èƒ½è¢«ç§°ä¸ºhtmlEscapeã€HTMLEscapeæˆ–escapeHTMLï¼Œä½†ä¸ä¼šæ˜¯escapeHtmlã€‚*

#### 2.2.å£°æ˜

Goè¯­è¨€ä¸»è¦æœ‰å››ç§ç±»å‹çš„å£°æ˜è¯­å¥ï¼švarã€constã€typeå’Œfuncï¼Œåˆ†åˆ«å¯¹åº”å˜é‡ã€å¸¸é‡ã€ç±»å‹å’Œå‡½æ•°å®ä½“å¯¹è±¡çš„å£°æ˜ã€‚

*ä¸€ä¸ªGoè¯­è¨€ç¼–å†™çš„ç¨‹åºå¯¹åº”ä¸€ä¸ªæˆ–å¤šä¸ªä»¥.goä¸ºæ–‡ä»¶åç¼€åçš„æºæ–‡ä»¶ã€‚æ¯ä¸ªæºæ–‡ä»¶ä¸­ä»¥**åŒ…çš„å£°æ˜è¯­å¥å¼€å§‹**ï¼Œè¯´æ˜è¯¥æºæ–‡ä»¶æ˜¯å±äºå“ªä¸ªåŒ…ã€‚åŒ…å£°æ˜è¯­å¥ä¹‹åæ˜¯i**mportè¯­å¥å¯¼å…¥ä¾èµ–çš„å…¶å®ƒåŒ…**ï¼Œç„¶åæ˜¯**åŒ…ä¸€çº§çš„ç±»å‹**ã€**å˜é‡ã€å¸¸é‡ã€å‡½æ•°çš„å£°æ˜è¯­å¥**ï¼Œ**åŒ…ä¸€çº§çš„å„ç§ç±»å‹çš„å£°æ˜è¯­å¥çš„é¡ºåºæ— å…³ç´§è¦*

```
// Boiling prints the boiling point of water.
package main

import "fmt"

const boilingF = 212.0

func main() {
    var f = boilingF
    var c = (f - 32) * 5 / 9
    fmt.Printf("boiling point = %gÂ°F or %gÂ°C\n", f, c)
    // Output:
    // boiling point = 212Â°F or 100Â°C
}

```

*å…¶ä¸­**å¸¸é‡boilingFæ˜¯åœ¨åŒ…ä¸€çº§èŒƒå›´å£°æ˜**è¯­å¥å£°æ˜çš„ï¼Œç„¶å**få’Œcä¸¤ä¸ªå˜é‡æ˜¯åœ¨mainå‡½æ•°å†…éƒ¨å£°æ˜**çš„å£°æ˜è¯­å¥å£°æ˜çš„ã€‚åœ¨åŒ…ä¸€çº§å£°æ˜è¯­å¥å£°æ˜çš„åå­—å¯åœ¨æ•´ä¸ªåŒ…å¯¹åº”çš„æ¯ä¸ªæºæ–‡ä»¶ä¸­è®¿é—®ï¼Œè€Œä¸æ˜¯ä»…ä»…åœ¨å…¶å£°æ˜è¯­å¥æ‰€åœ¨çš„æºæ–‡ä»¶ä¸­è®¿é—®ã€‚*

ä¾‹å¦‚ï¼š

a.go

```
// Boiling prints the boiling point of water.
package main

import "fmt"

const boilingF = 212

func main() {
		fmt.Println("Boiling point in Fahrenheit:", boilingF)
    printCelsius()

}
```

b.go

```
package main

import "fmt"

func printCelsius() {
		c := (boilingF - 32) * 5 / 9 // å¯ä»¥è®¿é—®boilingF
    fmt.Println("Boiling point in Celsius:", c)
}
```

æ‰§è¡Œ

```
â¯ go mod init example.com/myapp

go: creating new go.mod: module example.com/myapp
go: to add module requirements and sums:
        go mod tidy
        
â¯ go run .
Boiling point in Fahrenheit: 212
Boiling point in Celsius: 100
```



å‡½æ•°å£°æ˜çš„æ ¼å¼

```
func å‡½æ•°å(å‚æ•°åˆ—è¡¨) è¿”å›å€¼ç±»å‹ {
    // å‡½æ•°ä½“
}

å¦‚
func fToC(f float64) float64 {
    return (f - 32) * 5 / 9
}
```

ä¸€ä¸ªå‡½æ•°çš„å£°æ˜ç”±ä¸€ä¸ªå‡½æ•°åå­—ã€å‚æ•°åˆ—è¡¨ã€ä¸€ä¸ªå¯é€‰çš„è¿”å›å€¼åˆ—è¡¨å’ŒåŒ…å«å‡½æ•°å®šä¹‰çš„å‡½æ•°ä½“ç»„æˆã€‚å¦‚æœå‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼Œé‚£ä¹ˆè¿”å›å€¼åˆ—è¡¨æ˜¯çœç•¥çš„ã€‚æ‰§è¡Œå‡½æ•°ä»å‡½æ•°çš„ç¬¬ä¸€ä¸ªè¯­å¥å¼€å§‹ï¼Œä¾æ¬¡é¡ºåºæ‰§è¡Œç›´åˆ°é‡åˆ°returnè¿”å›è¯­å¥ï¼Œå¦‚æœæ²¡æœ‰è¿”å›è¯­å¥åˆ™æ˜¯æ‰§è¡Œåˆ°å‡½æ•°æœ«å°¾ï¼Œç„¶åè¿”å›åˆ°å‡½æ•°è°ƒç”¨è€…ã€‚

#### 2.3.å˜é‡

```
var å˜é‡åå­— ç±»å‹ = è¡¨è¾¾å¼
```

*é›¶å€¼åˆå§‹åŒ–ï¼šæ•°å€¼ç±»å‹å˜é‡å¯¹åº”çš„é›¶å€¼æ˜¯0ï¼Œå¸ƒå°”ç±»å‹å˜é‡å¯¹åº”çš„é›¶å€¼æ˜¯falseï¼Œå­—ç¬¦ä¸²ç±»å‹å¯¹åº”çš„é›¶å€¼æ˜¯ç©ºå­—ç¬¦ä¸²ï¼Œæ¥å£æˆ–å¼•ç”¨ç±»å‹ï¼ˆåŒ…æ‹¬sliceã€æŒ‡é’ˆã€mapã€chanå’Œå‡½æ•°ï¼‰å˜é‡å¯¹åº”çš„é›¶å€¼æ˜¯nilã€‚æ•°ç»„æˆ–ç»“æ„ä½“ç­‰èšåˆç±»å‹å¯¹åº”çš„é›¶å€¼æ˜¯æ¯ä¸ªå…ƒç´ æˆ–å­—æ®µéƒ½æ˜¯å¯¹åº”è¯¥ç±»å‹çš„é›¶å€¼ã€‚*

å¯ä»¥åœ¨ä¸€ä¸ªå£°æ˜è¯­å¥ä¸­åŒæ—¶å£°æ˜ä¸€ç»„å˜é‡

```
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

ä¸€ç»„å˜é‡ä¹Ÿå¯ä»¥é€šè¿‡è°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œç”±å‡½æ•°è¿”å›çš„å¤šä¸ªè¿”å›å€¼åˆå§‹åŒ–ï¼š

```Go
var f, err = os.Open(name) // os.Open returns a file and an error
```

##### 2.3.1.ç®€çŸ­å˜é‡å£°æ˜

*ä»¥â€œåå­— := è¡¨è¾¾å¼â€å½¢å¼å£°æ˜å˜é‡ï¼Œå˜é‡çš„ç±»å‹æ ¹æ®è¡¨è¾¾å¼æ¥è‡ªåŠ¨æ¨å¯¼ã€‚*

*varå½¢å¼çš„å£°æ˜è¯­å¥å¾€å¾€æ˜¯ç”¨äºéœ€è¦æ˜¾å¼æŒ‡å®šå˜é‡ç±»å‹çš„åœ°æ–¹ï¼Œæˆ–è€…å› ä¸ºå˜é‡ç¨åä¼šè¢«é‡æ–°èµ‹å€¼è€Œåˆå§‹å€¼æ— å…³ç´§è¦çš„åœ°æ–¹*

```
i := 100                  // an int
var boiling float64 = 100 // a float64
var names []string
var err error
var p Point
```

*ç®€çŸ­å˜é‡å£°æ˜è¯­å¥ä¹Ÿå¯ä»¥ç”¨æ¥å£°æ˜å’Œåˆå§‹åŒ–ä¸€ç»„å˜é‡ï¼š*

```go
i, j := 0, 1
```

*è¿™ç§åŒæ—¶å£°æ˜å¤šä¸ªå˜é‡çš„æ–¹å¼åº”è¯¥é™åˆ¶åªåœ¨å¯ä»¥æé«˜ä»£ç å¯è¯»æ€§çš„åœ°æ–¹ä½¿ç”¨ï¼Œæ¯”å¦‚forè¯­å¥çš„å¾ªç¯çš„åˆå§‹åŒ–è¯­å¥éƒ¨åˆ†ã€‚*

ç®€çŸ­å˜é‡å£°æ˜è¯­å¥ä¸­å¿…é¡»è‡³å°‘è¦å£°æ˜ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œä¸‹é¢çš„ä»£ç å°†ä¸èƒ½ç¼–è¯‘é€šè¿‡ï¼š

```Go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```

##### 2.3.2. æŒ‡é’ˆ

å¦‚æœç”¨â€œvar x intâ€å£°æ˜è¯­å¥å£°æ˜ä¸€ä¸ªxå˜é‡ï¼Œé‚£ä¹ˆ&xè¡¨è¾¾å¼ï¼ˆå–xå˜é‡çš„å†…å­˜åœ°å€ï¼‰å°†äº§ç”Ÿä¸€ä¸ªæŒ‡å‘è¯¥æ•´æ•°å˜é‡çš„æŒ‡é’ˆï¼ŒæŒ‡é’ˆå¯¹åº”çš„æ•°æ®ç±»å‹æ˜¯`*int`ï¼ŒæŒ‡é’ˆè¢«ç§°ä¹‹ä¸ºâ€œæŒ‡å‘intç±»å‹çš„æŒ‡é’ˆâ€ã€‚å¦‚æœæŒ‡é’ˆåå­—ä¸ºpï¼Œé‚£ä¹ˆå¯ä»¥è¯´â€œpæŒ‡é’ˆæŒ‡å‘å˜é‡xâ€ï¼Œæˆ–è€…è¯´â€œpæŒ‡é’ˆä¿å­˜äº†xå˜é‡çš„å†…å­˜åœ°å€â€ã€‚åŒæ—¶`*p`è¡¨è¾¾å¼å¯¹åº”pæŒ‡é’ˆæŒ‡å‘çš„å˜é‡çš„å€¼ã€‚ä¸€èˆ¬`*p`è¡¨è¾¾å¼è¯»å–æŒ‡é’ˆæŒ‡å‘çš„å˜é‡çš„å€¼ï¼Œè¿™é‡Œä¸ºintç±»å‹çš„å€¼ï¼ŒåŒæ—¶å› ä¸º`*p`å¯¹åº”ä¸€ä¸ªå˜é‡ï¼Œæ‰€ä»¥è¯¥è¡¨è¾¾å¼ä¹Ÿå¯ä»¥å‡ºç°åœ¨èµ‹å€¼è¯­å¥çš„å·¦è¾¹ï¼Œè¡¨ç¤ºæ›´æ–°æŒ‡é’ˆæ‰€æŒ‡å‘çš„å˜é‡çš„å€¼ã€‚

```Go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

##### 2.3.3. newå‡½æ•°

å¦ä¸€ä¸ªåˆ›å»ºå˜é‡çš„æ–¹æ³•æ˜¯è°ƒç”¨å†…å»ºçš„newå‡½æ•°ã€‚è¡¨è¾¾å¼new(T)å°†åˆ›å»ºä¸€ä¸ªTç±»å‹çš„åŒ¿åå˜é‡ï¼Œåˆå§‹åŒ–ä¸ºTç±»å‹çš„é›¶å€¼ï¼Œç„¶åè¿”å›å˜é‡åœ°å€ï¼Œè¿”å›çš„æŒ‡é’ˆç±»å‹ä¸º`*T`ã€‚

```Go
p := new(int)   // p, *int ç±»å‹, æŒ‡å‘åŒ¿åçš„ int å˜é‡
fmt.Println(*p) // "0"
*p = 2          // è®¾ç½® int åŒ¿åå˜é‡çš„å€¼ä¸º 2
fmt.Println(*p) // "2"
```

##### 2.3.4. å˜é‡çš„ç”Ÿå‘½å‘¨æœŸ

*å˜é‡çš„ç”Ÿå‘½å‘¨æœŸæŒ‡çš„æ˜¯åœ¨ç¨‹åºè¿è¡ŒæœŸé—´å˜é‡æœ‰æ•ˆå­˜åœ¨çš„æ—¶é—´æ®µã€‚å¯¹äºåœ¨åŒ…ä¸€çº§å£°æ˜çš„å˜é‡æ¥è¯´ï¼Œå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸå’Œæ•´ä¸ªç¨‹åºçš„è¿è¡Œå‘¨æœŸæ˜¯ä¸€è‡´çš„ã€‚è€Œç›¸æ¯”ä¹‹ä¸‹ï¼Œå±€éƒ¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸåˆ™æ˜¯åŠ¨æ€çš„ï¼šæ¯æ¬¡ä»åˆ›å»ºä¸€ä¸ªæ–°å˜é‡çš„å£°æ˜è¯­å¥å¼€å§‹ï¼Œç›´åˆ°è¯¥å˜é‡ä¸å†è¢«å¼•ç”¨ä¸ºæ­¢ï¼Œç„¶åå˜é‡çš„å­˜å‚¨ç©ºé—´å¯èƒ½è¢«å›æ”¶ã€‚å‡½æ•°çš„å‚æ•°å˜é‡å’Œè¿”å›å€¼å˜é‡éƒ½æ˜¯å±€éƒ¨å˜é‡ã€‚å®ƒä»¬åœ¨å‡½æ•°æ¯æ¬¡è¢«è°ƒç”¨çš„æ—¶å€™åˆ›å»ºã€‚*

*ä¸€ä¸ªå˜é‡çš„æœ‰æ•ˆå‘¨æœŸåªå–å†³äºæ˜¯å¦å¯è¾¾ï¼Œä¸€ä¸ªå¾ªç¯è¿­ä»£å†…éƒ¨çš„å±€éƒ¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸå¯èƒ½è¶…å‡ºå…¶å±€éƒ¨ä½œç”¨åŸŸã€‚åŒæ—¶ï¼Œå±€éƒ¨å˜é‡å¯èƒ½åœ¨å‡½æ•°è¿”å›ä¹‹åä¾ç„¶å­˜åœ¨ã€‚*

*Goç¼–è¯‘å™¨ä¼šè‡ªåŠ¨é€‰æ‹©åœ¨æ ˆä¸Šè¿˜æ˜¯åœ¨å †ä¸Šåˆ†é…å±€éƒ¨å˜é‡çš„å­˜å‚¨ç©ºé—´ï¼Œ*

ğŸ”¹**1. æ ˆå’Œå †çš„åŒºåˆ«**

- **æ ˆï¼ˆstackï¼‰**ï¼šå¿«é€Ÿåˆ†é…/é‡Šæ”¾ï¼Œä½†ç”Ÿå‘½å‘¨æœŸä»…é™äºå‡½æ•°è°ƒç”¨æœŸé—´ã€‚
- **å †ï¼ˆheapï¼‰**ï¼šå†…å­˜æŒç»­æ—¶é—´æ›´é•¿ï¼Œä½†åˆ†é…/å›æ”¶è¾ƒæ…¢ï¼Œéœ€è¦åƒåœ¾å›æ”¶å™¨ï¼ˆGCï¼‰å¤„ç†ã€‚

------

ğŸ”¹**2. `var` å’Œ `new` å¹¶ä¸å†³å®šå†…å­˜ä½ç½®**

å¾ˆå¤šè¯­è¨€ï¼ˆæ¯”å¦‚ C/C++ï¼‰ä¸­ï¼Œä½ ç”¨ `new` å°±ä¼šåœ¨å †ä¸Šåˆ†é…ï¼Œç”¨å±€éƒ¨å˜é‡å°±ä¼šåœ¨æ ˆä¸Šåˆ†é…ã€‚ä½† **Go ä¸è¿™æ ·** â€”â€” å®ƒé€šè¿‡ç¼–è¯‘å™¨åˆ†æä»£ç æ¥å†³å®šå˜é‡åˆ°åº•æ˜¯åœ¨å †ä¸Šè¿˜æ˜¯æ ˆä¸Šåˆ†é…ã€‚

è¿™æ„å‘³ç€ï¼š
 âœ… ä½ å†™ `var x int`ï¼Œå®ƒ**å¯èƒ½åœ¨å †ä¸Š**
 âœ… ä½ å†™ `y := new(int)`ï¼Œå®ƒ**å¯èƒ½åœ¨æ ˆä¸Š**

è¿™ä¸ªå†³å®š **ä¸ç”±ä½ ä»£ç çš„è¯­æ³•å†³å®šï¼Œè€Œæ˜¯ç”±ç¼–è¯‘å™¨å¯¹å˜é‡æ˜¯å¦â€œé€ƒé€¸â€è¿›è¡Œåˆ¤æ–­å†³å®šçš„**ã€‚

------

ğŸ”¹**3. ä»€ä¹ˆæ˜¯â€œé€ƒé€¸â€ï¼Ÿ**

> â€œé€ƒé€¸â€æŒ‡çš„æ˜¯ä¸€ä¸ªå˜é‡åœ¨å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œä¾ç„¶å¯èƒ½è¢«å‡½æ•°å¤–éƒ¨çš„ä»£ç è®¿é—®ã€‚

å¦‚æœä¸€ä¸ªå˜é‡åœ¨å‡½æ•°è¿”å›ä¹‹åè¿˜è¦ç»§ç»­ç”¨ï¼Œ**å®ƒå°±ä¸èƒ½æ”¾åœ¨æ ˆä¸Š**ï¼Œå› ä¸ºå‡½æ•°è¿”å›æ—¶ï¼Œæ ˆç©ºé—´å°±ä¼šè¢«é‡Šæ”¾ã€‚è¿™æ ·å°±å¿…é¡»æŠŠå®ƒæ”¾åœ¨å †ä¸Šã€‚

------

ğŸ”¹**å…·ä½“ä¾‹å­åˆ†æï¼š**

ğŸ§© ç¤ºä¾‹ 1ï¼š

```
go


å¤åˆ¶ç¼–è¾‘
var global *int

func f() {
    var x int
    x = 1
    global = &x
}
```

- `x` æ˜¯ `f` å‡½æ•°å†…éƒ¨çš„å˜é‡ã€‚
- ä½†æˆ‘ä»¬æŠŠ `x` çš„åœ°å€ `&x` å­˜åˆ°äº†å…¨å±€å˜é‡ `global` ä¸­ã€‚
- æ‰€ä»¥ **å³ä½¿å‡½æ•° `f` è¿”å›äº†ï¼Œ`global` ä¾ç„¶å¯ä»¥è®¿é—® `x` çš„å€¼**ã€‚
- æ‰€ä»¥ `x` çš„ç”Ÿå‘½å‘¨æœŸè¶…å‡ºäº†å‡½æ•°ä½œç”¨åŸŸï¼Œä¹Ÿå°±æ˜¯â€œé€ƒé€¸â€äº†ã€‚
- ç¼–è¯‘å™¨å°±ä¼š **æŠŠ `x` æ”¾åˆ°å †ä¸Š**ã€‚

------

ğŸ§© ç¤ºä¾‹ 2ï¼š

```
go


å¤åˆ¶ç¼–è¾‘
func g() {
    y := new(int)
    *y = 1
}
```

- è¿™é‡Œç”¨äº† `new(int)`ï¼Œçœ‹èµ·æ¥æ˜¯â€œå †åˆ†é…â€ï¼Œä½†è¿™å¹¶ä¸æ˜¯å…³é”®ã€‚
- `y` æ˜¯å±€éƒ¨å˜é‡ï¼Œ`*y` ä¹Ÿåªåœ¨å‡½æ•° `g` ä¸­ä½¿ç”¨ã€‚
- `g` è¿”å›åï¼Œæ²¡äººå†ç”¨è¿™ä¸ªå˜é‡äº†ï¼Œå®ƒä¸ä¼šâ€œé€ƒé€¸â€ã€‚
- æ‰€ä»¥ç¼–è¯‘å™¨å¯èƒ½ **ä¼˜åŒ–æˆæ ˆä¸Šåˆ†é…**ï¼Œè€Œä¸æ˜¯æ”¾åˆ°å †ä¸Šã€‚

#### 2.4.èµ‹å€¼

ä½¿ç”¨èµ‹å€¼è¯­å¥å¯ä»¥æ›´æ–°ä¸€ä¸ªå˜é‡çš„å€¼ï¼Œæœ€ç®€å•çš„èµ‹å€¼è¯­å¥æ˜¯å°†è¦è¢«èµ‹å€¼çš„å˜é‡æ”¾åœ¨=çš„å·¦è¾¹ï¼Œæ–°å€¼çš„è¡¨è¾¾å¼æ”¾åœ¨=çš„å³è¾¹ã€‚

```Go
x = 1                       // å‘½åå˜é‡çš„èµ‹å€¼
*p = true                   // é€šè¿‡æŒ‡é’ˆé—´æ¥èµ‹å€¼
person.name = "bob"         // ç»“æ„ä½“å­—æ®µèµ‹å€¼
count[x] = count[x] * scale æˆ– count[x] *= scale
// æ•°ç»„ã€sliceæˆ–mapçš„å…ƒç´ èµ‹å€¼
```

æ•°å€¼å˜é‡ä¹Ÿå¯ä»¥æ”¯æŒ`++`é€’å¢å’Œ`--`é€’å‡è¯­å¥ï¼ˆè¯‘æ³¨ï¼šè‡ªå¢å’Œè‡ªå‡æ˜¯è¯­å¥ï¼Œè€Œä¸æ˜¯è¡¨è¾¾å¼

```
v := 1
v++    // ç­‰ä»·æ–¹å¼ v = v + 1ï¼›v å˜æˆ 2
v--    // ç­‰ä»·æ–¹å¼ v = v - 1ï¼›v å˜æˆ 1
```

##### 2.4.1. å…ƒç»„èµ‹å€¼

å…ƒç»„èµ‹å€¼æ˜¯å¦ä¸€ç§å½¢å¼çš„èµ‹å€¼è¯­å¥ï¼Œå®ƒå…è®¸åŒæ—¶æ›´æ–°å¤šä¸ªå˜é‡çš„å€¼ã€‚ä¾‹å¦‚æˆ‘ä»¬å¯ä»¥è¿™æ ·äº¤æ¢ä¸¤ä¸ªå˜é‡çš„å€¼ï¼š

```go
x, y = y, x

a[i], a[j] = a[j], a[i]
```

æœ‰äº›è¡¨è¾¾å¼ä¼šäº§ç”Ÿå¤šä¸ªå€¼ï¼Œæ¯”å¦‚è°ƒç”¨ä¸€ä¸ªæœ‰å¤šä¸ªè¿”å›å€¼çš„å‡½æ•°ã€‚

```go
f, err = os.Open("foo.txt") // function call returns two values
```

å’Œå˜é‡å£°æ˜ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸‹åˆ’çº¿ç©ºç™½æ ‡è¯†ç¬¦`_`æ¥ä¸¢å¼ƒä¸éœ€è¦çš„å€¼ã€‚

```go
_, err = io.Copy(dst, src) // ä¸¢å¼ƒå­—èŠ‚æ•°
_, ok = x.(T)              // åªæ£€æµ‹ç±»å‹ï¼Œå¿½ç•¥å…·ä½“å€¼
```

#### 2.5.ç±»å‹

*åœ¨ä»»ä½•ç¨‹åºä¸­éƒ½ä¼šå­˜åœ¨ä¸€äº›å˜é‡æœ‰ç€ç›¸åŒçš„å†…éƒ¨ç»“æ„ï¼Œä½†æ˜¯å´è¡¨ç¤ºå®Œå…¨ä¸åŒçš„æ¦‚å¿µã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªintç±»å‹çš„å˜é‡å¯ä»¥ç”¨æ¥è¡¨ç¤ºä¸€ä¸ªå¾ªç¯çš„è¿­ä»£ç´¢å¼•ã€æˆ–è€…ä¸€ä¸ªæ—¶é—´æˆ³ã€æˆ–è€…ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ã€æˆ–è€…ä¸€ä¸ªæœˆä»½ï¼›ä¸€ä¸ªfloat64ç±»å‹çš„å˜é‡å¯ä»¥ç”¨æ¥è¡¨ç¤ºæ¯ç§’ç§»åŠ¨å‡ ç±³çš„é€Ÿåº¦ã€æˆ–è€…æ˜¯ä¸åŒæ¸©åº¦å•ä½ä¸‹çš„æ¸©åº¦ï¼›ä¸€ä¸ªå­—ç¬¦ä¸²å¯ä»¥ç”¨æ¥è¡¨ç¤ºä¸€ä¸ªå¯†ç æˆ–è€…ä¸€ä¸ªé¢œè‰²çš„åç§°ã€‚*

```
type ç±»å‹åå­— åº•å±‚ç±»å‹
```



```go
// Package tempconv performs Celsius and Fahrenheit temperature computations.
package tempconv

import "fmt"

//å®šä¹‰äº†ä¸¤ä¸ªç±»å‹ï¼Œåº•å±‚éƒ½æ˜¯float64ï¼Œå®ƒä»¬æ˜¯ä¸åŒçš„æ•°æ®ç±»å‹ï¼Œå› æ­¤å®ƒä»¬ä¸å¯ä»¥è¢«ç›¸äº’æ¯”è¾ƒæˆ–æ··åœ¨ä¸€ä¸ªè¡¨è¾¾å¼è¿ç®—
type Celsius float64    // æ‘„æ°æ¸©åº¦
type Fahrenheit float64 // åæ°æ¸©åº¦

const (
    AbsoluteZeroC Celsius = -273.15 // ç»å¯¹é›¶åº¦
    FreezingC     Celsius = 0       // ç»“å†°ç‚¹æ¸©åº¦
    BoilingC      Celsius = 100     // æ²¸æ°´æ¸©åº¦
)

/*Celsius(t)å’ŒFahrenheit(t)æ˜¯ç±»å‹è½¬æ¢æ“ä½œï¼Œå®ƒä»¬å¹¶ä¸æ˜¯å‡½æ•°è°ƒç”¨ï¼Œç±»å‹è½¬æ¢ä¸ä¼šæ”¹å˜å€¼æœ¬èº«ï¼Œä½†æ˜¯ä¼šä½¿å®ƒä»¬çš„è¯­ä¹‰å‘ç”Ÿå˜åŒ–ã€‚
CToFå’ŒFToCä¸¤ä¸ªå‡½æ•°åˆ™æ˜¯å¯¹ä¸åŒæ¸©åº¦å•ä½ä¸‹çš„æ¸©åº¦è¿›è¡Œæ¢ç®—ï¼Œå®ƒä»¬ä¼šè¿”å›ä¸åŒçš„å€¼ã€‚*/
func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }

```



*å¯¹äºæ¯ä¸€ä¸ªç±»å‹Tï¼Œéƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ç±»å‹è½¬æ¢æ“ä½œT(x)ï¼Œç”¨äºå°†xè½¬ä¸ºTç±»å‹ï¼ˆè¯‘æ³¨ï¼šå¦‚æœTæ˜¯æŒ‡é’ˆç±»å‹ï¼Œå¯èƒ½ä¼šéœ€è¦ç”¨å°æ‹¬å¼§åŒ…è£…Tï¼Œæ¯”å¦‚`(*int)(0)`ï¼‰ã€‚åªæœ‰å½“ä¸¤ä¸ªç±»å‹çš„åº•å±‚åŸºç¡€ç±»å‹ç›¸åŒæ—¶ï¼Œæ‰å…è®¸è¿™ç§è½¬å‹æ“ä½œï¼Œæˆ–è€…æ˜¯ä¸¤è€…éƒ½æ˜¯æŒ‡å‘ç›¸åŒåº•å±‚ç»“æ„çš„æŒ‡é’ˆç±»å‹ï¼Œè¿™äº›è½¬æ¢åªæ”¹å˜ç±»å‹è€Œä¸ä¼šå½±å“å€¼æœ¬èº«ã€‚*



ä¸‹é¢çš„å£°æ˜è¯­å¥ï¼ŒCelsiusç±»å‹çš„å‚æ•°cå‡ºç°åœ¨äº†å‡½æ•°åçš„å‰é¢ï¼Œè¡¨ç¤ºå£°æ˜çš„æ˜¯Celsiusç±»å‹çš„ä¸€ä¸ªåå«Stringçš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•è¿”å›è¯¥ç±»å‹å¯¹è±¡cå¸¦ç€Â°Cæ¸©åº¦å•ä½çš„å­—ç¬¦ä¸²ï¼š

```Go
func (c Celsius) String() string { return fmt.Sprintf("%gÂ°C", c) }
```

#### 2.6.åŒ…å’Œæ–‡ä»¶



**ç»ƒä¹  2.1ï¼š** å†™ä¸€ä¸ªé€šç”¨çš„å•ä½è½¬æ¢ç¨‹åºï¼Œç”¨ç±»ä¼¼cfç¨‹åºçš„æ–¹å¼ä»å‘½ä»¤è¡Œè¯»å–å‚æ•°ï¼Œå¦‚æœç¼ºçœçš„è¯åˆ™æ˜¯ä»æ ‡å‡†è¾“å…¥è¯»å–å‚æ•°ï¼Œç„¶ååšç±»ä¼¼Celsiuså’ŒFahrenheitçš„å•ä½è½¬æ¢ï¼Œé•¿åº¦å•ä½å¯ä»¥å¯¹åº”è‹±å°ºå’Œç±³ï¼Œé‡é‡å•ä½å¯ä»¥å¯¹åº”ç£…å’Œå…¬æ–¤ç­‰ã€‚

ç›®å½•ç»“æ„ï¼š

```
â¯ tree
.
â”œâ”€â”€ go.mod
â”œâ”€â”€ main.go
â””â”€â”€ tempconv
    â”œâ”€â”€ conv.go
    â”œâ”€â”€ go.mod
    â””â”€â”€ tempconv.go
```

```
go mod init local/tempconv
```

go.mod

```
module local/myapp

go 1.24.4

replace local/tempconv => ./tempconv

require local/tempconv v0.0.0-00010101000000-000000000000 // indirect
```

main.go

```
package main

import (
	"fmt"
	"local/tempconv" // æ³¨æ„è¿™é‡Œçš„æ¨¡å—åå¿…é¡»ä¸ä½  go.mod ä¸­çš„ä¸€è‡´
)

func main() {
	k := tempconv.Kelvin(273.15)
	c := tempconv.KToC(k)

	fmt.Println("k:", k)       // è¾“å‡ºï¼š273.15K
	fmt.Println("k to c :", c) // è¾“å‡ºï¼š0Â°C
}

```

conv.go

```go
package tempconv

// CToF converts a Celsius temperature to Fahrenheit.
func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

// FToC converts a Fahrenheit temperature to Celsius.
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }

func CToK(c Celsius) Kelvin { return Kelvin(c + 273.15) }

func KToC(k Kelvin) Celsius { return Celsius(k - 273.15) }

```

tempconv.go

```go
// Package tempconv performs Celsius and Fahrenheit conversions.
package tempconv

import "fmt"

type Celsius float64
type Fahrenheit float64
type Kelvin float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	BoilingC      Celsius = 100
	AbsoluteZeroK Kelvin  = 0
)

func (c Celsius) String() string    { return fmt.Sprintf("%gÂ°C", c) }
func (f Fahrenheit) String() string { return fmt.Sprintf("%gÂ°F", f) }
func (k Kelvin) String() string     { return fmt.Sprintf("%gK", k) }

```

**ç»ƒä¹  2.2ï¼š** å†™ä¸€ä¸ªé€šç”¨çš„å•ä½è½¬æ¢ç¨‹åºï¼Œç”¨ç±»ä¼¼cfç¨‹åºçš„æ–¹å¼ä»å‘½ä»¤è¡Œè¯»å–å‚æ•°ï¼Œå¦‚æœç¼ºçœçš„è¯åˆ™æ˜¯ä»æ ‡å‡†è¾“å…¥è¯»å–å‚æ•°ï¼Œç„¶ååšç±»ä¼¼Celsiuså’ŒFahrenheitçš„å•ä½è½¬æ¢ï¼Œé•¿åº¦å•ä½å¯ä»¥å¯¹åº”è‹±å°ºå’Œç±³ï¼Œé‡é‡å•ä½å¯ä»¥å¯¹åº”ç£…å’Œå…¬æ–¤ç­‰ã€‚

```go
// ä»è¾“å…¥å‚æ•°è¿›è¡Œé‡é‡è½¬æ¢
package main

import (
	"fmt"
	"os"
	"strconv"
)

type ounce float64
type gram float64

func (o ounce) String() string { return fmt.Sprintf("%g oz", o) }
func (g gram) String() string  { return fmt.Sprintf("%g g", g) }

func OToG(o ounce) gram { return gram(o * 28.3495) }

func GToO(g gram) ounce { return ounce(g / 28.3495) }

func main() {
	for _, args := range os.Args[1:] {
		t, err := strconv.ParseFloat(args, 64)
		if err != nil {
			fmt.Fprintf(os.Stderr, "weightconv: %v\n", err)
			os.Exit(1)
		}
		o := ounce(t)
		g := OToG(o)
		fmt.Printf("%s = %s\n", o, g)
		g2 := GToO(g)
		fmt.Printf("%s = %s\n", g, g2)
	}
}

```

